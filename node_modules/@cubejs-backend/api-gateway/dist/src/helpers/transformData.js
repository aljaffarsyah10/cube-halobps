"use strict";
/**
 * @license Apache-2.0
 * @copyright Cube Dev, Inc.
 * @fileoverview
 * transformData function and related types definition.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformData = exports.getVanilaRow = exports.getCompactRow = exports.getMembers = exports.getBlendingResponseKey = exports.getBlendingQueryKey = exports.getDateRangeValue = exports.MEMBER_SEPARATOR = exports.BLENDING_QUERY_RES_SEPARATOR = exports.BLENDING_QUERY_KEY_PREFIX = exports.COMPARE_DATE_RANGE_SEPARATOR = exports.COMPARE_DATE_RANGE_FIELD = void 0;
const ramda_1 = __importDefault(require("ramda"));
const UserError_1 = require("../UserError");
const transformValue_1 = require("./transformValue");
const enums_1 = require("../types/enums");
const COMPARE_DATE_RANGE_FIELD = 'compareDateRange';
exports.COMPARE_DATE_RANGE_FIELD = COMPARE_DATE_RANGE_FIELD;
const COMPARE_DATE_RANGE_SEPARATOR = ' - ';
exports.COMPARE_DATE_RANGE_SEPARATOR = COMPARE_DATE_RANGE_SEPARATOR;
const BLENDING_QUERY_KEY_PREFIX = 'time.';
exports.BLENDING_QUERY_KEY_PREFIX = BLENDING_QUERY_KEY_PREFIX;
const BLENDING_QUERY_RES_SEPARATOR = '.';
exports.BLENDING_QUERY_RES_SEPARATOR = BLENDING_QUERY_RES_SEPARATOR;
const MEMBER_SEPARATOR = '.';
exports.MEMBER_SEPARATOR = MEMBER_SEPARATOR;
/**
 * Parse date range value from time dimension.
 * @internal
 */
function getDateRangeValue(timeDimensions) {
    if (!timeDimensions) {
        throw new UserError_1.UserError('QueryTimeDimension should be specified ' +
            'for the compare date range query.');
    }
    else {
        const [dim] = timeDimensions;
        if (!dim.dateRange) {
            throw new UserError_1.UserError(`${'Inconsistent QueryTimeDimension configuration ' +
                'for the compare date range query, dateRange required: '}${dim}`);
        }
        else if (typeof dim.dateRange === 'string') {
            throw new UserError_1.UserError('Inconsistent dateRange configuration for the ' +
                `compare date range query: ${dim.dateRange}`);
        }
        else {
            return dim.dateRange.join(COMPARE_DATE_RANGE_SEPARATOR);
        }
    }
}
exports.getDateRangeValue = getDateRangeValue;
/**
 * Parse blending query key from time time dimension.
 * @internal
 */
function getBlendingQueryKey(timeDimensions) {
    if (!timeDimensions) {
        throw new UserError_1.UserError('QueryTimeDimension should be specified ' +
            'for the blending query.');
    }
    else {
        const [dim] = timeDimensions;
        if (!dim.granularity) {
            throw new UserError_1.UserError('Inconsistent QueryTimeDimension configuration ' +
                `for the blending query, granularity required: ${dim}`);
        }
        else {
            return BLENDING_QUERY_KEY_PREFIX + dim.granularity;
        }
    }
}
exports.getBlendingQueryKey = getBlendingQueryKey;
/**
 * Parse blending response key from time time dimension.
 * @internal
 */
function getBlendingResponseKey(timeDimensions) {
    if (!timeDimensions) {
        throw new UserError_1.UserError('QueryTimeDimension should be specified ' +
            'for the blending query.');
    }
    else {
        const [dim] = timeDimensions;
        if (!dim.granularity) {
            throw new UserError_1.UserError('Inconsistent QueryTimeDimension configuration ' +
                `for the blending query, granularity required: ${dim}`);
        }
        else if (!dim.dimension) {
            throw new UserError_1.UserError('Inconsistent QueryTimeDimension configuration ' +
                `for the blending query, dimension required: ${dim}`);
        }
        else {
            return dim.dimension +
                BLENDING_QUERY_RES_SEPARATOR +
                dim.granularity;
        }
    }
}
exports.getBlendingResponseKey = getBlendingResponseKey;
/**
 * Parse members names from request/response.
 * @internal
 */
function getMembers(queryType, query, dbData, aliasToMemberNameMap, annotation) {
    const members = {};
    if (!dbData.length) {
        return members;
    }
    const columns = Object.keys(dbData[0]);
    columns.forEach((column) => {
        if (!aliasToMemberNameMap[column] || !annotation[aliasToMemberNameMap[column]]) {
            throw new UserError_1.UserError(`You requested hidden member: '${column}'. Please make it visible using \`shown: true\`. ` +
                'Please note primaryKey fields are `shown: false` by ' +
                'default: https://cube.dev/docs/schema/reference/joins#' +
                'setting-a-primary-key.');
        }
        members[aliasToMemberNameMap[column]] = column;
        const path = aliasToMemberNameMap[column]
            .split(MEMBER_SEPARATOR);
        const calcMember = [path[0], path[1]].join(MEMBER_SEPARATOR);
        if (path.length === 3 &&
            query.dimensions?.indexOf(calcMember) === -1) {
            members[calcMember] = column;
        }
    });
    if (queryType === enums_1.QueryType.COMPARE_DATE_RANGE_QUERY) {
        members[COMPARE_DATE_RANGE_FIELD] =
            enums_1.QueryType.COMPARE_DATE_RANGE_QUERY;
    }
    else if (queryType === enums_1.QueryType.BLENDING_QUERY) {
        members[getBlendingQueryKey(query.timeDimensions)] =
            // @ts-ignore
            members[query.timeDimensions[0].dimension];
    }
    return members;
}
exports.getMembers = getMembers;
/**
 * Convert DB response object to the compact output format.
 * @internal
 * @todo should we use transformValue for blending query?
 */
function getCompactRow(membersToAliasMap, annotation, queryType, members, timeDimensions, dbRow) {
    const row = [];
    members.forEach((m) => {
        if (annotation[m]) {
            row.push((0, transformValue_1.transformValue)(dbRow[membersToAliasMap[m]], annotation[m].type));
        }
    });
    if (queryType === enums_1.QueryType.COMPARE_DATE_RANGE_QUERY) {
        row.push(getDateRangeValue(timeDimensions));
    }
    else if (queryType === enums_1.QueryType.BLENDING_QUERY) {
        row.push(dbRow[membersToAliasMap[getBlendingResponseKey(timeDimensions)]]);
    }
    return row;
}
exports.getCompactRow = getCompactRow;
/**
 * Convert DB response object to the vanila output format.
 * @todo rewrite me please!
 * @internal
 */
function getVanilaRow(aliasToMemberNameMap, annotation, queryType, query, dbRow) {
    const row = ramda_1.default.pipe(ramda_1.default.toPairs, ramda_1.default.map(p => {
        const memberName = aliasToMemberNameMap[p[0]];
        const annotationForMember = annotation[memberName];
        if (!annotationForMember) {
            throw new UserError_1.UserError(`You requested hidden member: '${p[0]}'. Please make it visible using \`shown: true\`. ` +
                'Please note primaryKey fields are `shown: false` by ' +
                'default: https://cube.dev/docs/schema/reference/joins#' +
                'setting-a-primary-key.');
        }
        const transformResult = [
            memberName,
            (0, transformValue_1.transformValue)(p[1], annotationForMember.type)
        ];
        const path = memberName.split(MEMBER_SEPARATOR);
        /**
         * Time dimensions without granularity.
         * @deprecated
         * @todo backward compatibility for referencing
         */
        const memberNameWithoutGranularity = [path[0], path[1]].join(MEMBER_SEPARATOR);
        if (path.length === 3 &&
            (query.dimensions || [])
                .indexOf(memberNameWithoutGranularity) === -1) {
            return [
                transformResult,
                [
                    memberNameWithoutGranularity,
                    transformResult[1]
                ]
            ];
        }
        return [transformResult];
    }), 
    // @ts-ignore
    ramda_1.default.unnest, ramda_1.default.fromPairs
    // @ts-ignore
    )(dbRow);
    if (queryType === enums_1.QueryType.COMPARE_DATE_RANGE_QUERY) {
        return {
            ...row,
            compareDateRange: getDateRangeValue(query.timeDimensions)
        };
    }
    else if (queryType === enums_1.QueryType.BLENDING_QUERY) {
        return {
            ...row,
            [getBlendingQueryKey(query.timeDimensions)]: row[getBlendingResponseKey(query.timeDimensions)]
        };
    }
    return row;
}
exports.getVanilaRow = getVanilaRow;
/**
 * Transforms queried data array to the output format.
 */
function transformData(aliasToMemberNameMap, annotation, data, query, queryType, resType) {
    const d = data;
    const membersToAliasMap = getMembers(queryType, query, d, aliasToMemberNameMap, annotation);
    const members = Object.keys(membersToAliasMap);
    const dataset = d.map((r) => {
        const row = resType === enums_1.ResultType.COMPACT
            ? getCompactRow(membersToAliasMap, annotation, queryType, members, query.timeDimensions, r)
            : getVanilaRow(aliasToMemberNameMap, annotation, queryType, query, r);
        return row;
    });
    return (resType === enums_1.ResultType.COMPACT
        ? { members, dataset }
        : dataset);
}
exports.transformData = transformData;
exports.default = transformData;
//# sourceMappingURL=transformData.js.map