"use strict";
/**
 * @license Apache-2.0
 * @copyright Cube Dev, Inc.
 * @fileoverview
 * prepareAnnotation function and related types definition.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAnnotation = exports.annotation = void 0;
const ramda_1 = __importDefault(require("ramda"));
const toConfigMap_1 = require("./toConfigMap");
const enums_1 = require("../types/enums");
/**
 * Returns annotations by MetaConfigMap and cube's member type.
 */
const annotation = (configMap, memberType) => (member) => {
    const [cubeName, fieldName] = member.expression ? [member.cubeName, member.name] : member.split('.');
    const memberWithoutGranularity = [cubeName, fieldName].join('.');
    const config = configMap[cubeName][memberType]
        .find(m => m.name === memberWithoutGranularity);
    if (!config) {
        return undefined;
    }
    return [typeof member === 'string' ? member : memberWithoutGranularity, {
            title: config.title,
            shortTitle: config.shortTitle,
            description: config.description,
            type: config.type,
            format: config.format,
            meta: config.meta,
            ...(memberType === enums_1.MemberType.MEASURES ? {
                drillMembers: config.drillMembers,
                drillMembersGrouped: config.drillMembersGrouped
            } : {})
        }];
};
exports.annotation = annotation;
/**
 * Returns annotations object by MetaConfigs and query.
 */
function prepareAnnotation(metaConfig, query) {
    const configMap = (0, toConfigMap_1.toConfigMap)(metaConfig);
    const dimensions = (query.dimensions || []);
    return {
        measures: ramda_1.default.fromPairs((query.measures || []).map(annotation(configMap, enums_1.MemberType.MEASURES)).filter(a => !!a)),
        dimensions: ramda_1.default.fromPairs(dimensions
            .map(annotation(configMap, enums_1.MemberType.DIMENSIONS))
            .filter(a => !!a)),
        segments: ramda_1.default.fromPairs((query.segments || [])
            .map(annotation(configMap, enums_1.MemberType.SEGMENTS))
            .filter(a => !!a)),
        timeDimensions: ramda_1.default.fromPairs(ramda_1.default.unnest((query.timeDimensions || [])
            .filter(td => !!td.granularity)
            .map(td => [
            annotation(configMap, enums_1.MemberType.DIMENSIONS)(`${td.dimension}.${td.granularity}`)
        ].concat(
        // TODO: deprecated: backward compatibility for
        // referencing time dimensions without granularity
        dimensions.indexOf(td.dimension) === -1
            ? [
                annotation(configMap, enums_1.MemberType.DIMENSIONS)(td.dimension)
            ]
            : []).filter(a => !!a)))),
    };
}
exports.prepareAnnotation = prepareAnnotation;
exports.default = prepareAnnotation;
//# sourceMappingURL=prepareAnnotation.js.map