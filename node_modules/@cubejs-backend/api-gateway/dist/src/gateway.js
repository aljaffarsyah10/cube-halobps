"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiGateway = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const ramda_1 = __importDefault(require("ramda"));
const body_parser_1 = __importDefault(require("body-parser"));
const express_graphql_1 = require("express-graphql");
const structured_clone_1 = __importDefault(require("@ungap/structured-clone"));
const shared_1 = require("@cubejs-backend/shared");
const enums_1 = require("./types/enums");
const requestParser_1 = require("./requestParser");
const UserError_1 = require("./UserError");
const CubejsHandlerError_1 = require("./CubejsHandlerError");
const SubscriptionServer_1 = require("./SubscriptionServer");
const LocalSubscriptionStore_1 = require("./LocalSubscriptionStore");
const query_1 = require("./query");
const cached_handler_1 = require("./cached-handler");
const jwk_1 = require("./jwk");
const sql_server_1 = require("./sql-server");
const graphql_1 = require("./graphql");
const prepareAnnotation_1 = require("./helpers/prepareAnnotation");
const transformData_1 = __importDefault(require("./helpers/transformData"));
const transformMetaExtended_1 = require("./helpers/transformMetaExtended");
const memberExpressionRegex = /^([a-zA-Z0-9_]+).([a-zA-Z0-9_]+):\(([a-zA-Z0-9_,]+)\):(.*)$/;
function userAsyncHandler(handler) {
    return (req, res, next) => {
        handler(req, res).catch(next);
    };
}
function systemAsyncHandler(handler) {
    return (req, res, next) => {
        handler(req, res).catch(next);
    };
}
class ApiGateway {
    constructor(apiSecret, compilerApi, adapterApi, logger, options) {
        this.apiSecret = apiSecret;
        this.compilerApi = compilerApi;
        this.adapterApi = adapterApi;
        this.logger = logger;
        this.options = options;
        this.contextToApiScopesDefFn = async () => ['graphql', 'meta', 'data'];
        this.releaseListeners = [];
        this.handleErrorMiddleware = async (e, req, res, next) => {
            this.handleError({
                e,
                context: req.context,
                res: this.resToResultFn(res),
                requestStarted: new Date(),
            });
            next(e);
        };
        this.checkAuth = async (req, res, next) => {
            await this.checkAuthWrapper(this.checkAuthFn, req, res, next);
        };
        this.checkAuthSystemMiddleware = async (req, res, next) => {
            await this.checkAuthWrapper(this.checkAuthSystemFn, req, res, next);
        };
        this.requestContextMiddleware = async (req, res, next) => {
            try {
                req.context = await this.contextByReq(req, req.securityContext, (0, requestParser_1.getRequestIdFromRequest)(req));
                if (next) {
                    next();
                }
            }
            catch (e) {
                if (next) {
                    next(e);
                }
                else {
                    throw e;
                }
            }
        };
        this.requestLogger = async (req, res, next) => {
            const details = (0, requestParser_1.requestParser)(req, res);
            this.log({ type: 'REST API Request', ...details }, req.context);
            if (next) {
                next();
            }
        };
        this.logNetworkUsage = async (req, res, next) => {
            this.log({
                type: 'Incoming network usage',
                service: 'api-http',
                bytes: Buffer.byteLength(req.url + req.rawHeaders.join('\n')) + (Number(req.get('content-length')) || 0),
                path: req.path,
            }, req.context);
            res.on('finish', () => {
                this.log({
                    type: 'Outgoing network usage',
                    service: 'api-http',
                    bytes: Number(res.get('content-length')) || 0,
                    path: req.path,
                }, req.context);
            });
            if (next) {
                next();
            }
        };
        this.createSystemContextHandler = (basePath) => {
            const body = {
                basePath,
                dockerVersion: (0, shared_1.getEnv)('dockerImageVersion') || null,
                serverCoreVersion: this.options.serverCoreVersion || null
            };
            return (req, res) => {
                res.status(200).json(body);
            };
        };
        this.readiness = async (req, res) => {
            let health = 'HEALTH';
            if (this.standalone) {
                try {
                    const orchestratorApi = await this.adapterApi({});
                    // todo: test other data sources
                    orchestratorApi.addDataSeenSource('default');
                    await orchestratorApi.testConnection();
                    await orchestratorApi.testOrchestratorConnections();
                }
                catch (e) {
                    this.logProbeError(e, 'Internal Server Error on readiness probe');
                    health = 'DOWN';
                }
            }
            return this.healthResponse(res, health);
        };
        this.liveness = async (req, res) => {
            let health = 'HEALTH';
            try {
                await this.dataSourceStorage.testConnections();
                // @todo Optimize this moment?
                await this.dataSourceStorage.testOrchestratorConnections();
            }
            catch (e) {
                this.logProbeError(e, 'Internal Server Error on liveness probe');
                health = 'DOWN';
            }
            return this.healthResponse(res, health);
        };
        this.dataSourceStorage = options.dataSourceStorage;
        this.refreshScheduler = options.refreshScheduler;
        this.scheduledRefreshContexts = options.scheduledRefreshContexts;
        this.scheduledRefreshTimeZones = options.scheduledRefreshTimeZones;
        this.standalone = options.standalone;
        this.basePath = options.basePath;
        this.playgroundAuthSecret = options.playgroundAuthSecret;
        this.queryRewrite = options.queryRewrite || (async (query) => query);
        this.subscriptionStore = options.subscriptionStore || new LocalSubscriptionStore_1.LocalSubscriptionStore();
        this.enforceSecurityChecks = options.enforceSecurityChecks || (process.env.NODE_ENV === 'production');
        this.extendContext = options.extendContext;
        this.checkAuthFn = this.createCheckAuthFn(options);
        this.checkAuthSystemFn = this.createCheckAuthSystemFn();
        this.contextToApiScopesFn = this.createContextToApiScopesFn(options);
        this.checkAuthMiddleware = options.checkAuthMiddleware
            ? this.wrapCheckAuthMiddleware(options.checkAuthMiddleware)
            : this.checkAuth;
        this.securityContextExtractor = this.createSecurityContextExtractor(options.jwt);
        this.requestLoggerMiddleware = options.requestLoggerMiddleware || this.requestLogger;
        this.contextRejectionMiddleware = options.contextRejectionMiddleware || (async (req, res, next) => next());
        this.wsContextAcceptor = options.wsContextAcceptor || (() => ({ accepted: true }));
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.event = options.event || function () { };
    }
    initApp(app) {
        const userMiddlewares = [
            this.checkAuthMiddleware,
            this.requestContextMiddleware,
            this.contextRejectionMiddleware,
            this.logNetworkUsage,
            this.requestLoggerMiddleware
        ];
        /** **************************************************************
         * No scope                                              *
         *************************************************************** */
        // @todo Should we pass requestLoggerMiddleware?
        const guestMiddlewares = [];
        app.get('/readyz', guestMiddlewares, (0, cached_handler_1.cachedHandler)(this.readiness));
        app.get('/livez', guestMiddlewares, (0, cached_handler_1.cachedHandler)(this.liveness));
        /** **************************************************************
         * graphql scope                                                 *
         *************************************************************** */
        app.use(`${this.basePath}/graphql`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.assertApiScope('graphql', req?.context?.securityContext);
            const compilerApi = await this.getCompilerApi(req.context);
            let schema = compilerApi.getGraphQLSchema();
            if (!schema) {
                let metaConfig = await compilerApi.metaConfig({
                    requestId: req.context.requestId,
                });
                metaConfig = this.filterVisibleItemsInMeta(req.context, metaConfig);
                schema = (0, graphql_1.makeSchema)(metaConfig);
                compilerApi.setGraphQLSchema(schema);
            }
            return (0, express_graphql_1.graphqlHTTP)({
                schema,
                context: {
                    req,
                    apiGateway: this
                },
                graphiql: (0, shared_1.getEnv)('nodeEnv') !== 'production'
                    ? { headerEditorEnabled: true }
                    : false,
            })(req, res);
        }));
        /** **************************************************************
         * data scope                                                    *
         *************************************************************** */
        app.get(`${this.basePath}/v1/load`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.load({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.query.queryType,
            });
        }));
        const jsonParser = body_parser_1.default.json({ limit: '1mb' });
        app.post(`${this.basePath}/v1/load`, jsonParser, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.load({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.body.queryType
            });
        }));
        app.get(`${this.basePath}/v1/subscribe`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.load({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.query.queryType
            });
        }));
        app.get(`${this.basePath}/v1/sql`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.sql({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.post(`${this.basePath}/v1/sql`, jsonParser, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.sql({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.get(`${this.basePath}/v1/dry-run`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.dryRun({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.post(`${this.basePath}/v1/dry-run`, jsonParser, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.dryRun({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        /** **************************************************************
         * meta scope                                                    *
         *************************************************************** */
        app.get(`${this.basePath}/v1/meta`, userMiddlewares, userAsyncHandler(async (req, res) => {
            if ('extended' in req.query) {
                await this.metaExtended({
                    context: req.context,
                    res: this.resToResultFn(res),
                });
            }
            else {
                await this.meta({
                    context: req.context,
                    res: this.resToResultFn(res),
                });
            }
        }));
        // Used by Rollup Designer
        app.post(`${this.basePath}/v1/pre-aggregations/can-use`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.assertApiScope('meta', req?.context?.securityContext);
            const { transformedQuery, references } = req.body;
            const compilerApi = await this.getCompilerApi(req.context);
            const canUsePreAggregationForTransformedQuery = compilerApi.canUsePreAggregationForTransformedQuery(transformedQuery, references);
            res.json({ canUsePreAggregationForTransformedQuery });
        }));
        /** **************************************************************
         * jobs scope                                                    *
         *************************************************************** */
        app.get(`${this.basePath}/v1/run-scheduled-refresh`, userMiddlewares, userAsyncHandler(async (req, res) => {
            await this.runScheduledRefresh({
                queryingOptions: req.query.queryingOptions,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.post(`${this.basePath}/v1/pre-aggregations/jobs`, userMiddlewares, userAsyncHandler(this.preAggregationsJobs.bind(this)));
        /** **************************************************************
         * Private API (no scopes)                                       *
         *************************************************************** */
        if (this.playgroundAuthSecret) {
            const systemMiddlewares = [
                this.checkAuthSystemMiddleware,
                this.requestContextMiddleware,
                this.contextRejectionMiddleware,
                this.requestLoggerMiddleware
            ];
            app.get('/cubejs-system/v1/context', systemMiddlewares, this.createSystemContextHandler(this.basePath));
            app.get('/cubejs-system/v1/pre-aggregations', systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.getPreAggregations({
                    cacheOnly: !!req.query.cacheOnly,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.get('/cubejs-system/v1/pre-aggregations/security-contexts', systemMiddlewares, systemAsyncHandler(async (req, res) => {
                const contexts = this.scheduledRefreshContexts ? await this.scheduledRefreshContexts() : [];
                this.resToResultFn(res)({
                    securityContexts: contexts
                        .map(ctx => ctx && (ctx.securityContext || ctx.authInfo))
                        .filter(ctx => ctx)
                });
            }));
            app.get('/cubejs-system/v1/pre-aggregations/timezones', systemMiddlewares, systemAsyncHandler(async (req, res) => {
                this.resToResultFn(res)({
                    timezones: this.scheduledRefreshTimeZones || []
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/partitions', jsonParser, systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.getPreAggregationPartitions({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/preview', jsonParser, systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.getPreAggregationPreview({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/build', jsonParser, systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.buildPreAggregations({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/queue', jsonParser, systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.getPreAggregationsInQueue({
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/cancel', jsonParser, systemMiddlewares, systemAsyncHandler(async (req, res) => {
                await this.cancelPreAggregationsFromQueue({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
        }
        app.use(this.handleErrorMiddleware);
    }
    initSQLServer() {
        return new sql_server_1.SQLServer(this);
    }
    initSubscriptionServer(sendMessage) {
        return new SubscriptionServer_1.SubscriptionServer(this, sendMessage, this.subscriptionStore, this.wsContextAcceptor);
    }
    duration(requestStarted) {
        return requestStarted && (new Date().getTime() - requestStarted.getTime());
    }
    async runScheduledRefresh({ context, res, queryingOptions }) {
        const requestStarted = new Date();
        try {
            await this.assertApiScope('jobs', context.securityContext);
            const refreshScheduler = this.refreshScheduler();
            res(await refreshScheduler.runScheduledRefresh(context, {
                ...this.parseQueryParam(queryingOptions || {}),
                throwErrors: true
            }));
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    filterVisibleItemsInMeta(context, cubes) {
        function visibilityFilter(item) {
            return (0, shared_1.getEnv)('devMode') || context.signedWithPlaygroundAuthSecret || item.isVisible;
        }
        return cubes
            .map((cube) => ({
            config: {
                ...cube.config,
                measures: cube.config.measures?.filter(visibilityFilter),
                dimensions: cube.config.dimensions?.filter(visibilityFilter),
                segments: cube.config.segments?.filter(visibilityFilter),
            },
        })).filter(cube => cube.config.measures?.length || cube.config.dimensions?.length || cube.config.segments?.length);
    }
    async meta({ context, res, includeCompilerId }) {
        const requestStarted = new Date();
        try {
            await this.assertApiScope('meta', context.securityContext);
            const compilerApi = await this.getCompilerApi(context);
            const metaConfig = await compilerApi.metaConfig({
                requestId: context.requestId,
                includeCompilerId
            });
            const cubesConfig = includeCompilerId ? metaConfig.cubes : metaConfig;
            const cubes = this.filterVisibleItemsInMeta(context, cubesConfig).map(cube => cube.config);
            const response = { cubes };
            if (includeCompilerId) {
                response.compilerId = metaConfig.compilerId;
            }
            res(response);
        }
        catch (e) {
            this.handleError({
                e,
                context,
                res,
                requestStarted,
            });
        }
    }
    async metaExtended({ context, res }) {
        const requestStarted = new Date();
        try {
            await this.assertApiScope('meta', context.securityContext);
            const compilerApi = await this.getCompilerApi(context);
            const metaConfigExtended = await compilerApi.metaConfigExtended({
                requestId: context.requestId,
            });
            const { metaConfig, cubeDefinitions } = metaConfigExtended;
            const cubes = this.filterVisibleItemsInMeta(context, metaConfig)
                .map((meta) => meta.config)
                .map((cube) => ({
                ...(0, transformMetaExtended_1.transformCube)(cube, cubeDefinitions),
                measures: cube.measures?.map((measure) => ({
                    ...(0, transformMetaExtended_1.transformMeasure)(measure, cubeDefinitions),
                })),
                dimensions: cube.dimensions?.map((dimension) => ({
                    ...(0, transformMetaExtended_1.transformDimension)(dimension, cubeDefinitions),
                })),
                segments: cube.segments?.map((segment) => ({
                    ...(0, transformMetaExtended_1.transformSegment)(segment, cubeDefinitions),
                })),
                joins: (0, transformMetaExtended_1.transformJoins)(cubeDefinitions[cube.name]?.joins),
                preAggregations: (0, transformMetaExtended_1.transformPreAggregations)(cubeDefinitions[cube.name]?.preAggregations),
            }));
            res({ cubes });
        }
        catch (e) {
            this.handleError({
                e,
                context,
                res,
                requestStarted,
            });
        }
    }
    async getPreAggregations({ cacheOnly, context, res }) {
        const requestStarted = new Date();
        try {
            const compilerApi = await this.getCompilerApi(context);
            const preAggregations = await compilerApi.preAggregations();
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, (0, query_1.normalizeQueryPreAggregations)({
                timezones: this.scheduledRefreshTimeZones,
                preAggregations: preAggregations.map(p => ({
                    id: p.id,
                    cacheOnly,
                }))
            }));
            res({ preAggregations: preAggregationPartitions.map(({ preAggregation }) => preAggregation) });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async getPreAggregationPartitions({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = (0, query_1.normalizeQueryPreAggregations)(this.parseQueryParam(query), { timezones: this.scheduledRefreshTimeZones });
            const orchestratorApi = await this.getAdapterApi(context);
            const compilerApi = await this.getCompilerApi(context);
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, query);
            const preAggregationPartitionsWithoutError = preAggregationPartitions.filter(p => !p?.errors?.length);
            const versionEntriesResult = preAggregationPartitions &&
                await orchestratorApi.getPreAggregationVersionEntries(context, preAggregationPartitionsWithoutError, compilerApi.preAggregationsSchema);
            const checkExpand = (path) => !query.expand ||
                (path instanceof RegExp
                    ? query.expand.some((p) => path.test(p))
                    : query.expand.includes(path));
            const mergePartitionsAndVersionEntries = () => ({ errors, preAggregation, partitions, invalidateKeyQueries, timezones }) => ({
                errors,
                invalidateKeyQueries,
                preAggregation,
                timezones,
                partitions: partitions.map(partition => ({
                    ...(checkExpand('partitions.details') ? partition : {}),
                    ...(checkExpand('partitions.meta') ? {
                        dataSource: partition.dataSource,
                        preAggregationId: partition.preAggregationId,
                        tableName: partition.tableName,
                        type: partition.type,
                    } : {}),
                    ...(checkExpand('partitions.versions') ? {
                        versionEntries: versionEntriesResult?.versionEntriesByTableName[partition?.tableName] || [],
                        structureVersion: versionEntriesResult?.structureVersionsByTableName[partition?.tableName] || [],
                    } : {}),
                })),
            });
            res({
                preAggregationPartitions: preAggregationPartitions.map(mergePartitionsAndVersionEntries())
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async getPreAggregationPreview({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = (0, query_1.normalizeQueryPreAggregationPreview)(this.parseQueryParam(query));
            const { preAggregationId, versionEntry, timezone } = query;
            const orchestratorApi = await this.getAdapterApi(context);
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, {
                timezones: [timezone],
                preAggregations: [{ id: preAggregationId }]
            });
            const { partitions } = (preAggregationPartitions && preAggregationPartitions[0] || {});
            const preAggregationPartition = partitions && partitions.find(p => p?.tableName === versionEntry.table_name);
            res({
                preview: preAggregationPartition && await orchestratorApi.getPreAggregationPreview(context, preAggregationPartition)
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async buildPreAggregations({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = (0, query_1.normalizeQueryPreAggregations)(this.parseQueryParam(query));
            const result = await this.refreshScheduler()
                .buildPreAggregations(context, query);
            res({ result });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    /**
     * Entry point for the `/cubejs-system/v1/pre-aggregations/jobs` endpoint.
     * Post object example:
     * ```
     * {
     *   "action": "post",
     *   "selector": {
     *     "contexts": [
     *       {"securityContext": {"tenant": "t1"}},
     *       {"securityContext": {"tenant": "t2"}}
     *     ],
     *     "timezones": ["UTC"],
     *     "dataSources": ["default"],
     *     "cubes": ["Events"],
     *     "preAggregations": ["Events.TemporaryData"]
     *   }
     * }
     * // or
     * {
     *   "action": "get",
     *   "tokens": [
     *     "ec1232ea3356f04f8be313fecf3deb4d",
     *     "48b75d5c466fa579c936dc451f498f69",
     *     "76509837091396dc204abb1016c48e75",
     *     "52264769f81f6ff62062a93d6f6fbdb2"
     *   ]
     * }
     * // or
     * {
     *   "action": "get",
     *   "resType": "object",
     *   "tokens": [
     *     "ec1232ea3356f04f8be313fecf3deb4d",
     *     "48b75d5c466fa579c936dc451f498f69",
     *     "76509837091396dc204abb1016c48e75",
     *     "52264769f81f6ff62062a93d6f6fbdb2"
     *   ]
     * }
     * ```
     * TODO (buntarb): selector object validator.
     */
    async preAggregationsJobs(req, res) {
        const response = this.resToResultFn(res);
        const started = new Date();
        const context = req.context;
        const query = req.body;
        let result;
        try {
            await this.assertApiScope('jobs', req?.context?.securityContext);
            switch (query.action) {
                case 'post':
                    if (!query.selector.timezones ||
                        query.selector.timezones.length === 0) {
                        throw new UserError_1.UserError('A user\'s selector must contain at least one time zone.');
                    }
                    if (!query.selector.contexts ||
                        query.selector.contexts.length === 0) {
                        throw new UserError_1.UserError('A user\'s selector must contain at least one context element.');
                    }
                    else {
                        let e = false;
                        query.selector.contexts.forEach((c) => {
                            if (!c.securityContext)
                                e = true;
                        });
                        if (e) {
                            throw new UserError_1.UserError('Every context element must contain the ' +
                                '\'securityContext\' property.');
                        }
                    }
                    result = await this.preAggregationsJobsPOST(context, query.selector);
                    if (result.length === 0) {
                        throw new UserError_1.UserError('A user\'s selector doesn\'t match any of the ' +
                            'pre-aggregations described by the Cube schemas.');
                    }
                    break;
                case 'get':
                    result = await this.preAggregationsJobsGET(context, query.tokens, query.resType);
                    break;
                default:
                    throw new Error(`The '${query.action}' action type doesn't supported.`);
            }
            this.event(`pre_aggregations_jobs_${query.action}`, {
                source: req.header('source') || 'unknown',
            });
            response(result, { status: 200 });
        }
        catch (e) {
            this.handleError({ e, context, query, res: response, started });
        }
    }
    /**
     * Post pre-aggregations build jobs entry point.
     */
    async preAggregationsJobsPOST(context, selector) {
        let jobs = [];
        if (!selector.contexts?.length) {
            jobs = await this.postPreAggregationsBuildJobs(context, selector);
        }
        else {
            const promise = Promise.all(selector.contexts.map(async (config) => {
                const ctx = {
                    ...context,
                    ...config,
                };
                const _jobs = await this.postPreAggregationsBuildJobs(ctx, selector);
                return _jobs;
            }));
            const resolve = await promise;
            resolve.forEach((_jobs) => {
                jobs = jobs.concat(_jobs);
            });
        }
        return jobs;
    }
    /**
     * Add pre-aggregations build job. Returns added jobs ids.
     */
    async postPreAggregationsBuildJobs(context, selector) {
        const compiler = await this.getCompilerApi(context);
        const { timezones } = selector;
        const preaggs = await compiler.preAggregations({
            dataSources: selector.dataSources,
            cubes: selector.cubes,
            preAggregationIds: selector.preAggregations,
        });
        if (preaggs.length === 0) {
            return [];
        }
        else {
            const jobs = await this
                .refreshScheduler()
                .postBuildJobs(context, {
                metadata: undefined,
                timezones,
                preAggregations: preaggs.map(p => ({
                    id: p.id,
                    cacheOnly: undefined,
                    partitions: undefined, // string[]
                })),
                forceBuildPreAggregations: undefined,
                throwErrors: false,
            });
            return jobs;
        }
    }
    /**
     * Get pre-aggregations build jobs entry point.
     */
    async preAggregationsJobsGET(context, tokens, resType = 'array') {
        const objResponse = {};
        const selector = await this
            .refreshScheduler()
            .getCachedBuildJobs(context, tokens);
        const metaCache = new Map();
        const promise = Promise.all(selector.map(async (selected, i) => {
            const ctx = { ...context, ...selected.context };
            const orchestrator = await this.getAdapterApi(ctx);
            const compiler = await this.getCompilerApi(ctx);
            const sel = {
                cubes: [selected.preagg.split('.')[0]],
                preAggregations: [selected.preagg],
                contexts: [selected.context],
                timezones: [selected.timezone],
                dataSources: [selected.dataSource],
            };
            if (selected.status.indexOf('done') === 0 ||
                selected.status.indexOf('failure') === 0) {
                // returning from the cache
                if (resType === 'object') {
                    objResponse[tokens[i]] = {
                        table: selected.target,
                        status: selected.status,
                        selector: sel,
                    };
                }
                else {
                    return {
                        token: tokens[i],
                        table: selected.target,
                        status: selected.status,
                        selector: sel,
                    };
                }
            }
            else {
                // checking the queue
                const status = await this.getPreAggJobQueueStatus(orchestrator, selected);
                if (status) {
                    // returning queued status
                    if (resType === 'object') {
                        objResponse[tokens[i]] = {
                            table: selected.target,
                            status,
                            selector: sel,
                        };
                    }
                    else {
                        return {
                            token: tokens[i],
                            table: selected.target,
                            status,
                            selector: sel,
                        };
                    }
                }
                else {
                    const key = JSON.stringify(ctx);
                    if (!metaCache.has(key)) {
                        metaCache.set(key, await compiler.metaConfigExtended(ctx));
                    }
                    // checking and fetching result status
                    const s = await this.getPreAggJobResultStatus(ctx.requestId, orchestrator, compiler, metaCache.get(key), selected, tokens[i]);
                    if (resType === 'object') {
                        objResponse[tokens[i]] = {
                            table: selected.target,
                            status: s,
                            selector: sel,
                        };
                    }
                    else {
                        return {
                            token: tokens[i],
                            table: selected.target,
                            status: s,
                            selector: sel,
                        };
                    }
                }
            }
            return undefined;
        }));
        const arrResponse = await promise;
        return resType === 'object'
            ? objResponse
            : arrResponse;
    }
    /**
     * Returns PreAggJob status if it still in queue, false otherwose.
     */
    async getPreAggJobQueueStatus(orchestrator, job) {
        let inQueue = false;
        let status = 'n/a';
        const queuedList = await orchestrator.getPreAggregationQueueStates();
        queuedList.forEach((item) => {
            if (item.queryHandler &&
                item.queryHandler === 'query' &&
                item.query &&
                item.query.requestId === job.request &&
                item.query.newVersionEntry.table_name === job.table &&
                item.query.newVersionEntry.structure_version === job.structure &&
                item.query.newVersionEntry.content_version === job.content &&
                item.query.newVersionEntry.last_updated_at === job.updated) {
                inQueue = true;
                switch (item.status[0]) {
                    case 'toProcess':
                        status = 'scheduled';
                        break;
                    case 'active':
                        status = 'processing';
                        break;
                    default:
                        status = item.status[0];
                        break;
                }
            }
        });
        return inQueue ? status : false;
    }
    /**
     * Returns PreAggJob execution status.
     */
    async getPreAggJobResultStatus(requestId, orchestrator, compiler, metadata, job, token) {
        const preaggs = await compiler.preAggregations();
        const preagg = preaggs.filter(pa => pa.id === job.preagg)[0];
        const cube = metadata.cubeDefinitions[preagg.cube];
        const [, status] = await orchestrator.isPartitionExist(requestId, preagg.preAggregation.external, cube.dataSource, compiler.preAggregationsSchema, job.target, job.key, token);
        return status;
    }
    async getPreAggregationsInQueue({ context, res }) {
        const requestStarted = new Date();
        try {
            const orchestratorApi = await this.getAdapterApi(context);
            res({
                result: await orchestratorApi.getPreAggregationQueueStates()
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async cancelPreAggregationsFromQueue({ query, context, res }) {
        const requestStarted = new Date();
        try {
            const { queryKeys, dataSource } = (0, query_1.normalizeQueryCancelPreAggregations)(this.parseQueryParam(query));
            const orchestratorApi = await this.getAdapterApi(context);
            res({
                result: await orchestratorApi.cancelPreAggregationQueriesFromQueue(queryKeys, dataSource)
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    /**
     * Convert incoming query parameter (JSON fetched from the HTTP) to
     * an array of query type and array of normalized queries.
     */
    async getNormalizedQueries(query, context, persistent = false) {
        query = this.parseQueryParam(query);
        let queryType = enums_1.QueryType.REGULAR_QUERY;
        if (!Array.isArray(query)) {
            query = this.compareDateRangeTransformer(query);
            if (Array.isArray(query)) {
                queryType = enums_1.QueryType.COMPARE_DATE_RANGE_QUERY;
            }
        }
        else {
            queryType = enums_1.QueryType.BLENDING_QUERY;
        }
        const queries = Array.isArray(query) ? query : [query];
        this.log({
            type: 'Query Rewrite',
            query
        }, context);
        const startTime = new Date().getTime();
        let normalizedQueries = await Promise.all(queries.map(async (currentQuery) => {
            const normalizedQuery = (0, query_1.normalizeQuery)(currentQuery, persistent);
            const rewrite = await this.queryRewrite(normalizedQuery, context);
            return (0, query_1.normalizeQuery)(rewrite, persistent);
        }));
        this.log({
            type: 'Query Rewrite completed',
            normalizedQueries,
            duration: new Date().getTime() - startTime,
            query
        }, context);
        normalizedQueries = normalizedQueries.map(q => (0, query_1.remapToQueryAdapterFormat)(q));
        if (normalizedQueries.find((currentQuery) => !currentQuery)) {
            throw new Error('queryTransformer returned null query. Please check your queryTransformer implementation');
        }
        if (queryType === enums_1.QueryType.BLENDING_QUERY) {
            const queryGranularity = (0, query_1.getQueryGranularity)(normalizedQueries);
            if (queryGranularity.length > 1) {
                throw new UserError_1.UserError('Data blending query granularities must match');
            }
            if (queryGranularity.filter(Boolean).length === 0) {
                throw new UserError_1.UserError('Data blending query without granularity is not supported');
            }
        }
        return [queryType, normalizedQueries];
    }
    async sql({ query, context, res, memberToAlias, exportAnnotatedSql, memberExpressions, expressionParams, disableExternalPreAggregations, disableLimitEnforcing, }) {
        const requestStarted = new Date();
        try {
            await this.assertApiScope('data', context.securityContext);
            query = this.parseQueryParam(query);
            if (memberExpressions) {
                query = this.parseMemberExpressionsInQueries(query);
            }
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context, disableLimitEnforcing);
            const sqlQueries = await Promise.all(normalizedQueries.map(async (normalizedQuery) => (await this.getCompilerApi(context)).getSql(this.coerceForSqlQuery({ ...normalizedQuery, memberToAlias, expressionParams, disableExternalPreAggregations }, context), {
                includeDebugInfo: (0, shared_1.getEnv)('devMode') || context.signedWithPlaygroundAuthSecret,
                exportAnnotatedSql,
            })));
            const toQuery = (sqlQuery) => ({
                ...sqlQuery,
                order: ramda_1.default.fromPairs(sqlQuery.order.map(({ id: key, desc }) => [key, desc ? 'desc' : 'asc']))
            });
            res(queryType === enums_1.QueryType.REGULAR_QUERY ?
                { sql: toQuery(sqlQueries[0]) } :
                sqlQueries.map((sqlQuery) => ({ sql: toQuery(sqlQuery) })));
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    parseMemberExpressionsInQueries(query) {
        if (Array.isArray(query)) {
            return query.map(q => this.parseMemberExpressionsInQuery(q));
        }
        else {
            return this.parseMemberExpressionsInQuery(query);
        }
    }
    parseMemberExpressionsInQuery(query) {
        return {
            ...query,
            measures: (query.measures || []).map(m => (typeof m === 'string' ? this.parseMemberExpression(m) : m)),
            dimensions: (query.dimensions || []).map(m => (typeof m === 'string' ? this.parseMemberExpression(m) : m)),
            segments: (query.segments || []).map(m => (typeof m === 'string' ? this.parseMemberExpression(m) : m)),
        };
    }
    parseMemberExpression(memberExpression) {
        const match = memberExpression.match(memberExpressionRegex);
        if (match) {
            const args = match[3].split(',');
            args.push(`return \`${match[4]}\``);
            return {
                cubeName: match[1],
                name: match[2],
                expressionName: match[2],
                expression: Function.constructor.apply(null, args),
                definition: memberExpression,
            };
        }
        else {
            return memberExpression;
        }
    }
    async sqlGenerators({ context, res }) {
        const requestStarted = new Date();
        try {
            const compilerApi = await this.getCompilerApi(context);
            const query = {
                requestId: context.requestId,
            };
            const cubeNameToDataSource = await compilerApi.cubeNameToDataSource(query);
            let dataSources = Object.keys(cubeNameToDataSource).map(c => cubeNameToDataSource[c]);
            dataSources = [...new Set(dataSources)];
            const dataSourceToSqlGenerator = (await Promise.all(dataSources.map(async (dataSource) => ({ [dataSource]: (await compilerApi.getSqlGenerator(query, dataSource)).sqlGenerator })))).reduce((a, b) => ({ ...a, ...b }), {});
            res({ cubeNameToDataSource, dataSourceToSqlGenerator });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    createSecurityContextExtractor(options) {
        if (options?.claimsNamespace) {
            return (ctx) => {
                if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {
                    if (options.claimsNamespace in ctx.securityContext) {
                        return ctx.securityContext[options.claimsNamespace];
                    }
                }
                return {};
            };
        }
        let checkAuthDeprecationShown = false;
        return (ctx) => {
            let securityContext = {};
            if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {
                if (ctx.securityContext.u) {
                    if (!checkAuthDeprecationShown) {
                        this.logger('JWT U Property Deprecation', {
                            warning: ('Storing security context in the u property within the payload is now deprecated, please migrate: ' +
                                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#authinfo')
                        });
                        checkAuthDeprecationShown = true;
                    }
                    securityContext = {
                        ...ctx.securityContext,
                        ...ctx.securityContext.u,
                    };
                    delete securityContext.u;
                }
                else {
                    securityContext = ctx.securityContext;
                }
            }
            return securityContext;
        };
    }
    coerceForSqlQuery(query, context) {
        return {
            ...query,
            timeDimensions: query.timeDimensions || [],
            contextSymbols: {
                securityContext: this.securityContextExtractor(context),
            },
            requestId: context.requestId
        };
    }
    async dryRun({ query, context, res }) {
        const requestStarted = new Date();
        try {
            await this.assertApiScope('data', context.securityContext);
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);
            const sqlQueries = await Promise.all(normalizedQueries.map(async (normalizedQuery) => (await this.getCompilerApi(context)).getSql(this.coerceForSqlQuery(normalizedQuery, context), {
                includeDebugInfo: (0, shared_1.getEnv)('devMode') || context.signedWithPlaygroundAuthSecret
            })));
            res({
                queryType,
                normalizedQueries,
                queryOrder: sqlQueries.map((sqlQuery) => ramda_1.default.fromPairs(sqlQuery.order.map(({ id: member, desc }) => [member, desc ? 'desc' : 'asc']))),
                transformedQueries: sqlQueries.map((sqlQuery) => sqlQuery.canUseTransformedQuery),
                pivotQuery: (0, query_1.getPivotQuery)(queryType, normalizedQueries)
            });
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    /**
     * Returns an array of sqlQuery objects for specified normalized
     * queries.
     * @internal
     */
    async getSqlQueriesInternal(context, normalizedQueries) {
        const sqlQueries = await Promise.all(normalizedQueries.map(async (normalizedQuery, index) => {
            const loadRequestSQLStarted = new Date();
            const sqlQuery = await (await this.getCompilerApi(context))
                .getSql(this.coerceForSqlQuery(normalizedQuery, context));
            this.log({
                type: 'Load Request SQL',
                duration: this.duration(loadRequestSQLStarted),
                query: normalizedQueries[index],
                sqlQuery
            }, context);
            return sqlQuery;
        }));
        return sqlQueries;
    }
    /**
     * Execute query and return adapter's result.
     * @internal
     */
    async getSqlResponseInternal(context, normalizedQuery, sqlQuery) {
        const queries = [{
                ...sqlQuery,
                query: sqlQuery.sql[0],
                values: sqlQuery.sql[1],
                continueWait: true,
                renewQuery: normalizedQuery.renewQuery,
                requestId: context.requestId,
                context,
                persistent: false,
            }];
        if (normalizedQuery.total) {
            const normalizedTotal = (0, structured_clone_1.default)(normalizedQuery);
            normalizedTotal.totalQuery = true;
            normalizedTotal.limit = null;
            normalizedTotal.rowLimit = null;
            normalizedTotal.offset = null;
            const [totalQuery] = await this.getSqlQueriesInternal(context, [normalizedTotal]);
            queries.push({
                ...totalQuery,
                query: totalQuery.sql[0],
                values: totalQuery.sql[1],
                continueWait: true,
                renewQuery: normalizedTotal.renewQuery,
                requestId: context.requestId,
                context
            });
        }
        const [response, total] = await Promise.all(queries.map(async (query) => {
            const res = await (await this.getAdapterApi(context))
                .executeQuery(query);
            return res;
        }));
        response.total = normalizedQuery.total
            ? Number(total.data[0][shared_1.QueryAlias.TOTAL_COUNT])
            : undefined;
        return response;
    }
    /**
     * Convert adapter's result and other request paramters to a final
     * result object.
     * @internal
     */
    getResultInternal(context, queryType, normalizedQuery, sqlQuery, annotation, response, responseType) {
        return {
            query: normalizedQuery,
            data: (0, transformData_1.default)(sqlQuery.aliasNameToMember, {
                ...annotation.measures,
                ...annotation.dimensions,
                ...annotation.timeDimensions
            }, response.data, normalizedQuery, queryType, responseType),
            lastRefreshTime: response.lastRefreshTime?.toISOString(),
            ...((0, shared_1.getEnv)('devMode') ||
                context.signedWithPlaygroundAuthSecret
                ? {
                    refreshKeyValues: response.refreshKeyValues,
                    usedPreAggregations: response.usedPreAggregations,
                    transformedQuery: sqlQuery.canUseTransformedQuery,
                    requestId: context.requestId,
                }
                : null),
            annotation,
            dataSource: response.dataSource,
            dbType: response.dbType,
            extDbType: response.extDbType,
            external: response.external,
            slowQuery: Boolean(response.slowQuery),
            total: normalizedQuery.total ? response.total : null,
        };
    }
    /**
     * Returns stream object which will be used to stream results from
     * the data source if applicable, returns `null` otherwise.
     */
    async stream(context, query) {
        const requestStarted = new Date();
        try {
            this.log({ type: 'Load Request', query, streaming: true }, context);
            const [, normalizedQueries] = await this.getNormalizedQueries(query, context, true);
            const sqlQuery = (await this.getSqlQueriesInternal(context, normalizedQueries))[0];
            const q = {
                ...sqlQuery,
                query: sqlQuery.sql[0],
                values: sqlQuery.sql[1],
                continueWait: true,
                renewQuery: false,
                requestId: context.requestId,
                context,
                persistent: true,
                forceNoCache: true,
            };
            const _stream = {
                originalQuery: query,
                normalizedQuery: normalizedQueries[0],
                streamingQuery: q,
                stream: await (await this.getAdapterApi(context)).streamQuery(q),
            };
            return _stream;
        }
        catch (err) {
            const e = err.message === 'Continue wait' ? { error: 'Continue wait' } : err;
            this.handleError({
                e,
                context,
                query,
                res: (errorObj) => {
                    throw errorObj;
                },
                requestStarted
            });
            return null;
        }
    }
    /**
     * Data queries APIs (`/load`, `/subscribe`) entry point. Used by
     * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the
     * data.
     */
    async load(request) {
        let query;
        const { context, res, apiType = 'rest', ...props } = request;
        const requestStarted = new Date();
        try {
            await this.assertApiScope('data', context.securityContext);
            query = this.parseQueryParam(request.query);
            let resType = enums_1.ResultType.DEFAULT;
            if (!Array.isArray(query) && query.responseFormat) {
                resType = query.responseFormat;
            }
            this.log({
                type: 'Load Request',
                query
            }, context);
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);
            let metaConfigResult = await (await this
                .getCompilerApi(context)).metaConfig({
                requestId: context.requestId
            });
            metaConfigResult = this.filterVisibleItemsInMeta(context, metaConfigResult);
            const sqlQueries = await this
                .getSqlQueriesInternal(context, normalizedQueries);
            let slowQuery = false;
            const results = await Promise.all(normalizedQueries.map(async (normalizedQuery, index) => {
                slowQuery = slowQuery ||
                    Boolean(sqlQueries[index].slowQuery);
                const annotation = (0, prepareAnnotation_1.prepareAnnotation)(metaConfigResult, normalizedQuery);
                const response = await this.getSqlResponseInternal(context, normalizedQuery, sqlQueries[index]);
                return this.getResultInternal(context, queryType, normalizedQuery, sqlQueries[index], annotation, response, resType);
            }));
            this.log({
                type: 'Load Request Success',
                query,
                duration: this.duration(requestStarted),
                apiType,
                isPlayground: Boolean(context.signedWithPlaygroundAuthSecret),
                queries: results.length,
                queriesWithPreAggregations: results.filter((r) => Object.keys(r.usedPreAggregations || {}).length).length,
                queriesWithData: results.filter((r) => r.data?.length).length,
                dbType: results.map(r => r.dbType),
            }, context);
            if (queryType !== enums_1.QueryType.REGULAR_QUERY &&
                props.queryType == null) {
                throw new UserError_1.UserError(`'${queryType}' query type is not supported by the client.` +
                    'Please update the client.');
            }
            if (props.queryType === 'multi') {
                res({
                    queryType,
                    results,
                    pivotQuery: (0, query_1.getPivotQuery)(queryType, normalizedQueries),
                    slowQuery
                });
            }
            else {
                res(results[0]);
            }
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    async sqlApiLoad(request) {
        let query = null;
        const { context, res, apiType = 'sql', } = request;
        const requestStarted = new Date();
        try {
            await this.assertApiScope('data', context.securityContext);
            query = this.parseQueryParam(request.query);
            let resType = enums_1.ResultType.DEFAULT;
            query = this.parseMemberExpressionsInQueries(query);
            if (!Array.isArray(query) && query.responseFormat) {
                resType = query.responseFormat;
            }
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context, request.streaming);
            const compilerApi = await this.getCompilerApi(context);
            let metaConfigResult = await compilerApi.metaConfig({
                requestId: context.requestId
            });
            metaConfigResult = this.filterVisibleItemsInMeta(context, metaConfigResult);
            const sqlQueries = await this
                .getSqlQueriesInternal(context, normalizedQueries.map(q => ({ ...q, disableExternalPreAggregations: request.sqlQuery })));
            let results;
            let slowQuery = false;
            const streamResponse = async (sqlQuery) => {
                const q = {
                    ...sqlQuery,
                    query: sqlQuery.query || sqlQuery.sql[0],
                    values: sqlQuery.values || sqlQuery.sql[1],
                    continueWait: true,
                    renewQuery: false,
                    requestId: context.requestId,
                    context,
                    persistent: true,
                    forceNoCache: true,
                };
                const adapterApi = await this.getAdapterApi(context);
                return {
                    stream: await adapterApi.streamQuery(q),
                };
            };
            if (request.sqlQuery) {
                const finalQuery = {
                    query: request.sqlQuery[0],
                    values: request.sqlQuery[1],
                    continueWait: true,
                    renewQuery: normalizedQueries[0].renewQuery,
                    requestId: context.requestId,
                    context,
                    ...sqlQueries[0],
                    // TODO Can we just pass through data? Ensure hidden members can't be queried
                    aliasNameToMember: null,
                };
                if (request.streaming) {
                    results = [await streamResponse(finalQuery)];
                }
                else {
                    const adapterApi = await this.getAdapterApi(context);
                    const response = await adapterApi.executeQuery(finalQuery);
                    const annotation = (0, prepareAnnotation_1.prepareAnnotation)(metaConfigResult, normalizedQueries[0]);
                    // TODO Can we just pass through data? Ensure hidden members can't be queried
                    results = [{
                            data: response.data,
                            annotation
                        }];
                }
            }
            else {
                results = await Promise.all(normalizedQueries.map(async (normalizedQuery, index) => {
                    slowQuery = slowQuery ||
                        Boolean(sqlQueries[index].slowQuery);
                    const annotation = (0, prepareAnnotation_1.prepareAnnotation)(metaConfigResult, normalizedQuery);
                    if (request.streaming) {
                        return streamResponse(sqlQueries[index]);
                    }
                    const response = await this.getSqlResponseInternal(context, normalizedQuery, sqlQueries[index]);
                    return this.getResultInternal(context, queryType, normalizedQuery, sqlQueries[index], annotation, response, resType);
                }));
            }
            res(request.streaming ? results[0] : {
                results,
            });
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    async subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }) {
        if (this.enforceSecurityChecks && !signedWithPlaygroundAuthSecret) {
            throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Only for signed with playground auth secret');
        }
        return (await this.getAdapterApi(context)).subscribeQueueEvents(connectionId, res);
    }
    async unSubscribeQueueEvents({ context, connectionId }) {
        return (await this.getAdapterApi(context)).unSubscribeQueueEvents(connectionId);
    }
    async subscribe({ query, context, res, subscribe, subscriptionState, queryType, apiType }) {
        const requestStarted = new Date();
        try {
            this.log({
                type: 'Subscribe',
                query
            }, context);
            let result = null;
            let error = null;
            if (!subscribe) {
                await this.load({ query, context, res, queryType, apiType });
                return;
            }
            // TODO subscribe to refreshKeys instead of constantly firing load
            await this.load({
                query,
                context,
                res: (message, opts) => {
                    if (!Array.isArray(message) && message.error) {
                        error = { message, opts };
                    }
                    else {
                        result = { message, opts };
                    }
                },
                queryType,
                apiType,
            });
            const state = await subscriptionState();
            if (result && (!state || JSON.stringify(state.result) !== JSON.stringify(result))) {
                res(result.message, result.opts);
            }
            else if (error) {
                res(error.message, error.opts);
            }
            await subscribe({ error, result });
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    resToResultFn(res) {
        return (message, { status } = {}) => (status ? res.status(status).json(message) : res.json(message));
    }
    parseQueryParam(query) {
        if (!query || query === 'undefined') {
            throw new UserError_1.UserError('Query param is required');
        }
        if (typeof query === 'string') {
            try {
                return JSON.parse(query);
            }
            catch (e) {
                throw new UserError_1.UserError(`Unable to decode query param as JSON, error: ${e.message}`);
            }
        }
        return query;
    }
    async getCompilerApi(context) {
        return this.compilerApi(context);
    }
    async getAdapterApi(context) {
        return this.adapterApi(context);
    }
    async contextByReq(req, securityContext, requestId) {
        const extensions = typeof this.extendContext === 'function' ? await this.extendContext(req) : {};
        return {
            securityContext,
            // Deprecated, but let's allow it for now.
            authInfo: securityContext,
            signedWithPlaygroundAuthSecret: Boolean(req.signedWithPlaygroundAuthSecret),
            requestId,
            ...extensions,
        };
    }
    handleError({ e, context, query, res, requestStarted }) {
        const requestId = (0, shared_1.getEnv)('devMode') || context?.signedWithPlaygroundAuthSecret ? context?.requestId : undefined;
        const plainError = e.plainMessages;
        if (e instanceof CubejsHandlerError_1.CubejsHandlerError) {
            this.log({
                type: e.type,
                query,
                error: e.message,
                duration: this.duration(requestStarted)
            }, context);
            res({ error: e.message, stack: e.stack, requestId, plainError }, { status: e.status });
        }
        else if (e.error === 'Continue wait') {
            this.log({
                type: 'Continue wait',
                query,
                error: e.message,
                duration: this.duration(requestStarted),
            }, context);
            res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 200 });
        }
        else if (e.error) {
            this.log({
                type: 'Orchestrator error',
                query,
                error: e.error,
                duration: this.duration(requestStarted),
            }, context);
            res({ error: e.message || e.error.message || e.error.toString(), requestId }, { status: 400 });
        }
        else if (e.type === 'UserError') {
            this.log({
                type: e.type,
                query,
                error: e.message,
                duration: this.duration(requestStarted)
            }, context);
            res({
                type: e.type,
                error: e.message,
                plainError,
                stack: e.stack,
                requestId
            }, { status: 400 });
        }
        else {
            this.log({
                type: 'Internal Server Error',
                query,
                error: e.stack || e.toString(),
                duration: this.duration(requestStarted)
            }, context);
            res({ error: e.toString(), stack: e.stack, requestId, plainError, }, { status: 500 });
        }
    }
    wrapCheckAuthMiddleware(fn) {
        this.logger('CheckAuthMiddleware Middleware Deprecation', {
            warning: ('Option checkAuthMiddleware is now deprecated in favor of checkAuth, please migrate: ' +
                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware')
        });
        let showWarningAboutNotObject = false;
        return (req, res, next) => {
            fn(req, res, (e) => {
                // We renamed authInfo to securityContext, but users can continue to use both ways
                if (req.securityContext && !req.authInfo) {
                    req.authInfo = req.securityContext;
                }
                else if (req.authInfo) {
                    req.securityContext = req.authInfo;
                }
                if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {
                    this.logger('Security Context Should Be Object', {
                        warning: (`Value of securityContext (previously authInfo) expected to be object, actual: ${(0, shared_1.getRealType)(req.securityContext)}`)
                    });
                    showWarningAboutNotObject = true;
                }
                next(e);
            });
        };
    }
    wrapCheckAuth(fn) {
        // We dont need to span all logs with deprecation message
        let warningShowed = false;
        // securityContext should be object
        let showWarningAboutNotObject = false;
        return async (req, auth) => {
            await fn(req, auth);
            // We renamed authInfo to securityContext, but users can continue to use both ways
            if (req.securityContext && !req.authInfo) {
                req.authInfo = req.securityContext;
            }
            else if (req.authInfo) {
                if (!warningShowed) {
                    this.logger('AuthInfo Deprecation', {
                        warning: ('authInfo was renamed to securityContext, please migrate: ' +
                            'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware')
                    });
                    warningShowed = true;
                }
                req.securityContext = req.authInfo;
            }
            if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {
                this.logger('Security Context Should Be Object', {
                    warning: (`Value of securityContext (previously authInfo) expected to be object, actual: ${(0, shared_1.getRealType)(req.securityContext)}`)
                });
                showWarningAboutNotObject = true;
            }
        };
    }
    createDefaultCheckAuth(options, internalOptions) {
        const verifyToken = (auth, secret) => jsonwebtoken_1.default.verify(auth, secret, {
            algorithms: options?.algorithms,
            issuer: options?.issuer,
            audience: options?.audience,
            subject: options?.subject,
        });
        let checkAuthFn = verifyToken;
        if (options?.jwkUrl) {
            const jwks = (0, jwk_1.createJWKsFetcher)(options, {
                onBackgroundException: (e) => {
                    this.logger('JWKs Background Fetching Error', {
                        error: e.message,
                    });
                },
            });
            this.releaseListeners.push(jwks.release);
            // Precache JWKs response to speedup first auth
            if (options.jwkUrl && typeof options.jwkUrl === 'string') {
                jwks.fetchOnly(options.jwkUrl).catch((e) => this.logger('JWKs Prefetching Error', {
                    error: e.message,
                }));
            }
            checkAuthFn = async (auth) => {
                const decoded = jsonwebtoken_1.default.decode(auth, { complete: true });
                if (!decoded) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Unable to decode JWT key');
                }
                if (!decoded.header || !decoded.header.kid) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'JWT without kid inside headers');
                }
                const jwk = await jwks.getJWKbyKid(typeof options.jwkUrl === 'function' ? await options.jwkUrl(decoded) : options.jwkUrl, decoded.header.kid);
                if (!jwk) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', `Unable to verify, JWK with kid: "${decoded.header.kid}" not found`);
                }
                return verifyToken(auth, jwk);
            };
        }
        const secret = options?.key || this.apiSecret;
        return async (req, auth) => {
            if (auth) {
                try {
                    req.securityContext = await checkAuthFn(auth, secret);
                    req.signedWithPlaygroundAuthSecret = Boolean(internalOptions?.isPlaygroundCheckAuth);
                }
                catch (e) {
                    if (this.enforceSecurityChecks) {
                        throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Invalid token', e);
                    }
                }
            }
            else if (this.enforceSecurityChecks) {
                // @todo Move it to 401 or 400
                throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Authorization header isn\'t set');
            }
        };
    }
    createCheckAuthFn(options) {
        const mainCheckAuthFn = options.checkAuth
            ? this.wrapCheckAuth(options.checkAuth)
            : this.createDefaultCheckAuth(options.jwt);
        if (this.playgroundAuthSecret) {
            const systemCheckAuthFn = this.createCheckAuthSystemFn();
            return async (ctx, authorization) => {
                try {
                    await mainCheckAuthFn(ctx, authorization);
                }
                catch (error) {
                    await systemCheckAuthFn(ctx, authorization);
                }
            };
        }
        return (ctx, authorization) => mainCheckAuthFn(ctx, authorization);
    }
    createCheckAuthSystemFn() {
        const systemCheckAuthFn = this.createDefaultCheckAuth({
            key: this.playgroundAuthSecret,
            algorithms: ['HS256']
        }, { isPlaygroundCheckAuth: true });
        return async (ctx, authorization) => {
            await systemCheckAuthFn(ctx, authorization);
        };
    }
    createContextToApiScopesFn(options) {
        return options.contextToApiScopes
            ? async (securityContext, defaultApiScopes) => {
                const scopes = options.contextToApiScopes &&
                    await options.contextToApiScopes(securityContext, defaultApiScopes);
                if (!scopes || !Array.isArray(scopes)) {
                    throw new Error('A user-defined contextToApiScopes function returns an inconsistent type.');
                }
                else {
                    scopes.forEach((p) => {
                        if (['graphql', 'meta', 'data', 'jobs'].indexOf(p) === -1) {
                            throw new Error(`A user-defined contextToApiScopes function returns a wrong scope: ${p}`);
                        }
                    });
                }
                return scopes;
            }
            : async () => {
                const defaultApiScope = (0, shared_1.getEnv)('defaultApiScope');
                if (defaultApiScope) {
                    return defaultApiScope;
                }
                else {
                    return this.contextToApiScopesDefFn();
                }
            };
    }
    async assertApiScope(scope, securityContext) {
        const scopes = await this.contextToApiScopesFn(securityContext || {}, (0, shared_1.getEnv)('defaultApiScope') || await this.contextToApiScopesDefFn());
        const permited = scopes.indexOf(scope) >= 0;
        if (!permited) {
            throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', `API scope is missing: ${scope}`);
        }
    }
    extractAuthorizationHeaderWithSchema(req) {
        if (typeof req.headers.authorization === 'string') {
            const parts = req.headers.authorization.split(' ', 2);
            if (parts.length === 1) {
                return parts[0];
            }
            return parts[1];
        }
        return undefined;
    }
    async checkAuthWrapper(checkAuthFn, req, res, next) {
        const token = this.extractAuthorizationHeaderWithSchema(req);
        try {
            await checkAuthFn(req, token);
            if (next) {
                next();
            }
        }
        catch (e) {
            if (e instanceof CubejsHandlerError_1.CubejsHandlerError) {
                const error = e.originalError || e;
                this.log({
                    type: error.message,
                    url: req.url,
                    token,
                    error: error.stack || error.toString()
                }, req);
                res.status(e.status).json({ error: e.message });
            }
            else if (e instanceof Error) {
                this.log({
                    type: 'Auth Error',
                    token,
                    error: e.stack || e.toString()
                }, req);
                res.status(500).json({
                    error: e.toString(),
                    stack: e.stack
                });
            }
        }
    }
    compareDateRangeTransformer(query) {
        let queryCompareDateRange;
        let compareDateRangeTDIndex;
        (query.timeDimensions || []).forEach((td, index) => {
            if (td.compareDateRange != null) {
                if (queryCompareDateRange != null) {
                    throw new UserError_1.UserError('compareDateRange can only exist for one timeDimension');
                }
                queryCompareDateRange = td.compareDateRange;
                compareDateRangeTDIndex = index;
            }
        });
        if (queryCompareDateRange == null) {
            return query;
        }
        return queryCompareDateRange.map((dateRange) => ({
            ...ramda_1.default.clone(query),
            timeDimensions: query.timeDimensions.map((td, index) => {
                if (compareDateRangeTDIndex === index) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { compareDateRange, ...timeDimension } = td;
                    return {
                        ...timeDimension,
                        dateRange
                    };
                }
                return td;
            })
        }));
    }
    log(event, context) {
        const { type, ...restParams } = event;
        this.logger(type, {
            ...restParams,
            ...(!context ? undefined : {
                securityContext: context.securityContext,
                requestId: context.requestId,
                ...(!context.appName ? undefined : { appName: context.appName }),
                ...(!context.protocol ? undefined : { protocol: context.protocol }),
                ...(!context.apiType ? undefined : { apiType: context.apiType }),
            })
        });
    }
    healthResponse(res, health) {
        res.status(health === 'HEALTH' ? 200 : 500).json({
            health,
        });
    }
    logProbeError(e, type) {
        this.log({
            type,
            driverType: e.driverType,
            error: e.stack || e.toString(),
        });
    }
    release() {
        for (const releaseListener of this.releaseListeners) {
            releaseListener();
        }
    }
}
exports.ApiGateway = ApiGateway;
//# sourceMappingURL=gateway.js.map