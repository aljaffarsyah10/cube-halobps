"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeStoreCacheDriver = void 0;
const shared_1 = require("@cubejs-backend/shared");
class CubeStoreCacheDriver {
    constructor(connectionFactory) {
        this.connectionFactory = connectionFactory;
        this.connection = null;
        this.withLock = (key, cb, expiration = 60, freeAfter = true) => (0, shared_1.createCancelablePromise)(async (tkn) => {
            if (tkn.isCanceled()) {
                return false;
            }
            const connection = (await this.getConnection());
            const rows = await connection.query('CACHE SET NX TTL ? ? ?', [expiration, key, '1']);
            if (rows && rows.length === 1 && rows[0]?.success === 'true') {
                if (tkn.isCanceled()) {
                    if (freeAfter) {
                        await connection.query('CACHE REMOVE ?', [
                            key
                        ]);
                    }
                    return false;
                }
                try {
                    await tkn.with(cb());
                }
                finally {
                    if (freeAfter) {
                        await connection.query('CACHE REMOVE ?', [
                            key
                        ]);
                    }
                }
                return true;
            }
            return false;
        });
    }
    async getConnection() {
        if (this.connection) {
            return this.connection;
        }
        // eslint-disable-next-line no-return-assign
        return this.connection = await this.connectionFactory();
    }
    async get(key) {
        const rows = await (await this.getConnection()).query('CACHE GET ?', [
            key
        ]);
        if (rows && rows.length === 1) {
            return JSON.parse(rows[0].value);
        }
        return null;
    }
    async set(key, value, expiration) {
        const strValue = JSON.stringify(value);
        await (await this.getConnection()).query('CACHE SET TTL ? ? ?', [expiration, key, strValue]);
        return {
            key,
            bytes: Buffer.byteLength(strValue),
        };
    }
    async remove(key) {
        await (await this.getConnection()).query('CACHE REMOVE ?', [
            key
        ]);
    }
    async keysStartingWith(prefix) {
        const rows = await (await this.getConnection()).query('CACHE KEYS ?', [
            prefix
        ]);
        return rows.map((row) => row.key);
    }
    async cleanup() {
        //
    }
    async testConnection() {
        return (await this.getConnection()).testConnection();
    }
}
exports.CubeStoreCacheDriver = CubeStoreCacheDriver;
//# sourceMappingURL=CubeStoreCacheDriver.js.map