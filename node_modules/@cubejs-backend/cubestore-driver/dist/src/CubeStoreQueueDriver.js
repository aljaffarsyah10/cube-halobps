"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeStoreQueueDriver = void 0;
const crypto_1 = __importDefault(require("crypto"));
const shared_1 = require("@cubejs-backend/shared");
function hashQueryKey(queryKey, processUid) {
    processUid = processUid || (0, shared_1.getProcessUid)();
    const hash = crypto_1.default.createHash('md5').update(JSON.stringify(queryKey)).digest('hex');
    if (typeof queryKey === 'object' && queryKey.persistent) {
        return `${hash}@${processUid}`;
    }
    return hash;
}
class CubestoreQueueDriverConnection {
    constructor(driver, options) {
        this.driver = driver;
        this.options = options;
    }
    redisHash(queryKey) {
        return hashQueryKey(queryKey, this.options.processUid);
    }
    prefixKey(queryKey) {
        return `${this.options.redisQueuePrefix}:${queryKey}`;
    }
    async addToQueue(keyScore, queryKey, orphanedTime, queryHandler, query, priority, options) {
        const data = {
            queryHandler,
            query,
            queryKey,
            stageQueryKey: options.stageQueryKey,
            priority,
            requestId: options.requestId,
            addedToQueueTime: new Date().getTime()
        };
        const values = [
            priority,
        ];
        if (options.orphanedTimeout) {
            values.push(options.orphanedTimeout);
        }
        values.push(this.prefixKey(this.redisHash(queryKey)));
        values.push(JSON.stringify(data));
        const rows = await this.driver.query(`QUEUE ADD PRIORITY ?${options.orphanedTimeout ? ' ORPHANED ?' : ''} ? ?`, values);
        if (rows && rows.length) {
            return [
                rows[0].added === 'true' ? 1 : 0,
                rows[0].id ? parseInt(rows[0].id, 10) : null,
                parseInt(rows[0].pending, 10),
                data.addedToQueueTime
            ];
        }
        throw new Error('Empty response on QUEUE ADD');
    }
    async getQueryAndRemove(hash, queueId) {
        return [await this.cancelQuery(hash, queueId)];
    }
    async cancelQuery(hash, queueId) {
        const rows = await this.driver.query('QUEUE CANCEL ?', [
            // queryKeyHash as compatibility fallback
            queueId || this.prefixKey(hash),
        ]);
        if (rows && rows.length) {
            return this.decodeQueryDefFromRow(rows[0], 'cancelQuery');
        }
        return null;
    }
    async freeProcessingLock(_hash, _processingId, _activated) {
        // nothing to do
    }
    async getActiveQueries() {
        const rows = await this.driver.query('QUEUE ACTIVE ?', [
            this.options.redisQueuePrefix
        ]);
        return rows.map((row) => [
            row.id,
            row.queue_id ? parseInt(row.queue_id, 10) : null,
        ]);
    }
    async getToProcessQueries() {
        const rows = await this.driver.query('QUEUE PENDING ?', [
            this.options.redisQueuePrefix
        ]);
        return rows.map((row) => [
            row.id,
            row.queue_id ? parseInt(row.queue_id, 10) : null,
        ]);
    }
    async getActiveAndToProcess() {
        return [
            // We don't return active queries, because it's useless
            // There is only one place where it's used, and it's QueryQueue.reconcileQueueImpl
            // Cube Store provides strict guarantees that queue item cannot be active & pending in the same time
            [],
            await this.getToProcessQueries()
        ];
    }
    async getNextProcessingId() {
        const rows = await this.driver.query('CACHE INCR ?', [
            `${this.options.redisQueuePrefix}:PROCESSING_COUNTER`
        ]);
        if (rows && rows.length) {
            return rows[0].value;
        }
        throw new Error('Unable to get next processing id');
    }
    async getQueryStageState(onlyKeys) {
        const rows = await this.driver.query(`QUEUE LIST ${onlyKeys ? '?' : 'WITH_PAYLOAD ?'}`, [
            this.options.redisQueuePrefix
        ]);
        const defs = {};
        const toProcess = [];
        const active = [];
        for (const row of rows) {
            if (!onlyKeys) {
                defs[row.id] = this.decodeQueryDefFromRow(row, 'getQueryStageState');
            }
            if (row.status === 'pending') {
                toProcess.push(row.id);
            }
            else if (row.status === 'active') {
                active.push(row.id);
                // TODO: getQueryStage is broken for Executing query stage...
                toProcess.push(row.id);
            }
        }
        return [active, toProcess, defs];
    }
    async getResult(queryKey) {
        const rows = await this.driver.query('QUEUE RESULT ?', [
            this.prefixKey(this.redisHash(queryKey)),
        ]);
        if (rows && rows.length) {
            return this.decodeQueryDefFromRow(rows[0], 'getResult');
        }
        return null;
    }
    async getStalledQueries() {
        const rows = await this.driver.query('QUEUE STALLED ? ?', [
            this.options.heartBeatTimeout * 1000,
            this.options.redisQueuePrefix
        ]);
        return rows.map((row) => [
            row.id,
            row.queue_id ? parseInt(row.queue_id, 10) : null,
        ]);
    }
    async getOrphanedQueries() {
        const rows = await this.driver.query('QUEUE ORPHANED ? ?', [
            this.options.orphanedTimeout * 1000,
            this.options.redisQueuePrefix
        ]);
        return rows.map((row) => [
            row.id,
            row.queue_id ? parseInt(row.queue_id, 10) : null,
        ]);
    }
    async getQueriesToCancel() {
        const rows = await this.driver.query('QUEUE TO_CANCEL ? ? ?', [
            this.options.heartBeatTimeout * 1000,
            this.options.orphanedTimeout * 1000,
            this.options.redisQueuePrefix,
        ]);
        return rows.map((row) => [
            row.id,
            row.queue_id ? parseInt(row.queue_id, 10) : null,
        ]);
    }
    decodeQueryDefFromRow(row, method) {
        if (!row.payload) {
            throw new Error(`Field payload is empty, incorrect response for ${method} method`);
        }
        const payload = JSON.parse(row.payload);
        if (row.extra) {
            return Object.assign(payload, JSON.parse(row.extra));
        }
        return payload;
    }
    async getQueryDef(hash, queueId) {
        const rows = await this.driver.query('QUEUE GET ?', [
            queueId || this.prefixKey(hash),
        ]);
        if (rows && rows.length) {
            return this.decodeQueryDefFromRow(rows[0], 'getQueryDef');
        }
        return null;
    }
    async optimisticQueryUpdate(hash, toUpdate, _processingId, queueId) {
        await this.driver.query('QUEUE MERGE_EXTRA ? ?', [
            // queryKeyHash as compatibility fallback
            queueId || this.prefixKey(hash),
            JSON.stringify(toUpdate)
        ]);
        return true;
    }
    release() {
        // nothing to release
    }
    async retrieveForProcessing(hash, _processingId) {
        const rows = await this.driver.query('QUEUE RETRIEVE EXTENDED CONCURRENCY ? ?', [
            this.options.concurrency,
            this.prefixKey(hash),
        ]);
        if (rows && rows.length) {
            const active = rows[0].active ? (rows[0].active).split(',') : [];
            const pending = parseInt(rows[0].pending, 10);
            if (rows[0].payload) {
                const def = this.decodeQueryDefFromRow(rows[0], 'retrieveForProcessing');
                return [
                    1,
                    rows[0].id ? parseInt(rows[0].id, 10) : null,
                    active,
                    pending,
                    def,
                    true
                ];
            }
            else {
                return [
                    0, null, active, pending, null, false
                ];
            }
        }
        return null;
    }
    async getResultBlocking(hash, queueId) {
        const rows = await this.driver.query('QUEUE RESULT_BLOCKING ? ?', [
            this.options.continueWaitTimeout * 1000,
            // queryKeyHash as compatibility fallback
            queueId || this.prefixKey(hash),
        ]);
        if (rows && rows.length) {
            return this.decodeQueryDefFromRow(rows[0], 'getResultBlocking');
        }
        return null;
    }
    async setResultAndRemoveQuery(hash, executionResult, _processingId, queueId) {
        const rows = await this.driver.query('QUEUE ACK ? ? ', [
            // queryKeyHash as compatibility fallback
            queueId || this.prefixKey(hash),
            executionResult ? JSON.stringify(executionResult) : executionResult
        ]);
        if (rows && rows.length === 1) {
            return rows[0].success === 'true';
        }
        // Backward compatibility for old Cube Store
        return true;
    }
    async updateHeartBeat(hash, queueId) {
        await this.driver.query('QUEUE HEARTBEAT ?', [
            // queryKeyHash as compatibility fallback
            queueId || this.prefixKey(hash),
        ]);
    }
}
class CubeStoreQueueDriver {
    constructor(driverFactory, options) {
        this.driverFactory = driverFactory;
        this.options = options;
        this.connection = null;
    }
    redisHash(queryKey) {
        return hashQueryKey(queryKey);
    }
    async getConnection() {
        if (this.connection) {
            return this.connection;
        }
        // eslint-disable-next-line no-return-assign
        return this.connection = await this.driverFactory();
    }
    async createConnection() {
        return new CubestoreQueueDriverConnection(await this.getConnection(), this.options);
    }
    release() {
        // nothing to release
    }
}
exports.CubeStoreQueueDriver = CubeStoreQueueDriver;
//# sourceMappingURL=CubeStoreQueueDriver.js.map