"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketConnection = void 0;
const ws_1 = __importDefault(require("ws"));
const flatbuffers = __importStar(require("flatbuffers"));
const shared_1 = require("@cubejs-backend/shared");
const uuid_1 = require("uuid");
const codegen_1 = require("../codegen");
class WebSocketConnection {
    constructor(url) {
        this.url = url;
        this.messageCounter = 1;
        this.maxConnectRetries = (0, shared_1.getEnv)('cubeStoreMaxConnectRetries');
        this.noHeartBeatTimeout = (0, shared_1.getEnv)('cubeStoreNoHeartBeatTimeout');
        this.currentConnectionTry = 0;
        this.connectionId = (0, uuid_1.v4)();
    }
    async initWebSocket() {
        if (!this.webSocket) {
            const webSocket = new ws_1.default(this.url);
            webSocket.readyPromise = new Promise((resolve, reject) => {
                webSocket.lastHeartBeat = new Date();
                const pingInterval = setInterval(() => {
                    if (webSocket.readyState === ws_1.default.OPEN) {
                        webSocket.ping();
                    }
                    if (new Date().getTime() - webSocket.lastHeartBeat.getTime() > this.noHeartBeatTimeout * 1000) {
                        webSocket.close();
                    }
                }, 5000);
                webSocket.sendAsync = async (message) => new Promise((resolveSend, rejectSend) => {
                    // If socket is closing this message should be resent
                    if (webSocket.readyState === ws_1.default.OPEN) {
                        webSocket.send(message, (err) => {
                            if (err) {
                                rejectSend(err);
                            }
                            else {
                                resolveSend();
                            }
                        });
                    }
                });
                webSocket.on('open', () => resolve(webSocket));
                webSocket.on('error', (err) => {
                    this.currentConnectionTry += 1;
                    if (this.currentConnectionTry < this.maxConnectRetries) {
                        setTimeout(async () => {
                            resolve(this.initWebSocket());
                        }, this.retryWaitTime());
                    }
                    else {
                        reject(err);
                    }
                    if (webSocket === this.webSocket) {
                        this.webSocket = undefined;
                    }
                });
                webSocket.on('pong', () => {
                    if (webSocket === this.webSocket) {
                        this.currentConnectionTry = 0;
                    }
                    webSocket.lastHeartBeat = new Date();
                });
                webSocket.on('close', () => {
                    clearInterval(pingInterval);
                    if (Object.keys(webSocket.sentMessages).length) {
                        setTimeout(async () => {
                            try {
                                const nextWebSocket = await this.initWebSocket();
                                // eslint-disable-next-line no-restricted-syntax
                                for (const key of Object.keys(webSocket.sentMessages)) {
                                    nextWebSocket.sentMessages[key] = webSocket.sentMessages[key];
                                    await nextWebSocket.sendAsync(webSocket.sentMessages[key].buffer);
                                }
                            }
                            catch (e) {
                                // eslint-disable-next-line no-restricted-syntax
                                for (const key of Object.keys(webSocket.sentMessages)) {
                                    webSocket.sentMessages[key].reject(e);
                                }
                            }
                        }, this.retryWaitTime());
                    }
                    if (webSocket === this.webSocket) {
                        this.webSocket = undefined;
                    }
                });
                webSocket.on('message', (msg) => {
                    const buf = new flatbuffers.ByteBuffer(msg);
                    const httpMessage = codegen_1.HttpMessage.getRootAsHttpMessage(buf);
                    const resolvers = webSocket.sentMessages[httpMessage.messageId()];
                    delete webSocket.sentMessages[httpMessage.messageId()];
                    if (!resolvers) {
                        throw new Error(`Cube Store missed message id: ${httpMessage.messageId()}`); // logging
                    }
                    const commandType = httpMessage.commandType();
                    if (commandType === codegen_1.HttpCommand.HttpError) {
                        resolvers.reject(new Error(`${httpMessage.command(new codegen_1.HttpError())?.error()}`));
                    }
                    else if (commandType === codegen_1.HttpCommand.HttpResultSet) {
                        const resultSet = httpMessage.command(new codegen_1.HttpResultSet());
                        if (!resultSet) {
                            resolvers.reject(new Error('Empty resultSet'));
                            return;
                        }
                        const columnsLen = resultSet.columnsLength();
                        const columns = [];
                        for (let i = 0; i < columnsLen; i++) {
                            const columnName = resultSet.columns(i);
                            if (!columnName) {
                                resolvers.reject(new Error('Column name is not defined'));
                                return;
                            }
                            columns.push(columnName);
                        }
                        const rowLen = resultSet.rowsLength();
                        const result = [];
                        for (let i = 0; i < rowLen; i++) {
                            const row = resultSet.rows(i);
                            if (!row) {
                                resolvers.reject(new Error('Null row'));
                                return;
                            }
                            const valueLen = row.valuesLength();
                            const rowObj = {};
                            for (let j = 0; j < valueLen; j++) {
                                const value = row.values(j);
                                rowObj[columns[j]] = value?.stringValue();
                            }
                            result.push(rowObj);
                        }
                        resolvers.resolve(result);
                    }
                    else {
                        resolvers.reject(new Error('Unsupported command'));
                    }
                });
            });
            webSocket.sentMessages = {};
            this.webSocket = webSocket;
        }
        return this.webSocket.readyPromise;
    }
    retryWaitTime() {
        return 1000 * (this.currentConnectionTry + 1);
    }
    async sendMessage(messageId, buffer) {
        const socket = await this.initWebSocket();
        return new Promise((resolve, reject) => {
            if (socket.readyState === ws_1.default.OPEN) {
                socket.send(buffer, (err) => {
                    if (err) {
                        delete socket.sentMessages[messageId];
                        reject(err);
                    }
                });
            }
            socket.sentMessages[messageId] = {
                resolve,
                reject,
                buffer
            };
        });
    }
    async query(query, inlineTables, queryTracingObj) {
        const builder = new flatbuffers.Builder(1024);
        const queryOffset = builder.createString(query);
        let traceObjOffset = null;
        if (queryTracingObj) {
            traceObjOffset = builder.createString(JSON.stringify(queryTracingObj));
        }
        let inlineTablesOffset = null;
        if (inlineTables && inlineTables.length > 0) {
            const inlineTableOffsets = [];
            for (const table of inlineTables) {
                const nameOffset = builder.createString(table.name);
                const columnOffsets = [];
                for (const column of table.columns) {
                    const columnOffset = builder.createString(column.name);
                    columnOffsets.push(columnOffset);
                }
                const columnsOffset = codegen_1.HttpTable.createColumnsVector(builder, columnOffsets);
                const typeOffsets = [];
                for (const column of table.columns) {
                    const typeOffset = builder.createString(column.type);
                    typeOffsets.push(typeOffset);
                }
                const typesOffset = codegen_1.HttpTable.createColumnsVector(builder, typeOffsets);
                const csvRowsOffset = builder.createString(table.csvRows);
                codegen_1.HttpTable.startHttpTable(builder);
                codegen_1.HttpTable.addName(builder, nameOffset);
                codegen_1.HttpTable.addColumns(builder, columnsOffset);
                codegen_1.HttpTable.addTypes(builder, typesOffset);
                codegen_1.HttpTable.addCsvRows(builder, csvRowsOffset);
                const inlineTableOffset = codegen_1.HttpTable.endHttpTable(builder);
                inlineTableOffsets.push(inlineTableOffset);
            }
            inlineTablesOffset = codegen_1.HttpQuery.createInlineTablesVector(builder, inlineTableOffsets);
        }
        codegen_1.HttpQuery.startHttpQuery(builder);
        codegen_1.HttpQuery.addQuery(builder, queryOffset);
        if (traceObjOffset) {
            codegen_1.HttpQuery.addTraceObj(builder, traceObjOffset);
        }
        if (inlineTablesOffset) {
            codegen_1.HttpQuery.addInlineTables(builder, inlineTablesOffset);
        }
        const httpQueryOffset = codegen_1.HttpQuery.endHttpQuery(builder);
        const messageId = this.messageCounter++;
        const connectionIdOffset = builder.createString(this.connectionId);
        const message = codegen_1.HttpMessage.createHttpMessage(builder, messageId, codegen_1.HttpCommand.HttpQuery, httpQueryOffset, connectionIdOffset);
        builder.finish(message);
        return this.sendMessage(messageId, builder.asUint8Array());
    }
    close() {
        if (this.webSocket) {
            this.webSocket.close();
        }
    }
}
exports.WebSocketConnection = WebSocketConnection;
//# sourceMappingURL=WebSocketConnection.js.map