"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSchemaCompiler = void 0;
const vm_1 = __importDefault(require("vm"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const syntax_error_1 = __importDefault(require("syntax-error"));
const parser_1 = require("@babel/parser");
const generator_1 = __importDefault(require("@babel/generator"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const ramda_1 = __importDefault(require("ramda"));
const shared_1 = require("@cubejs-backend/shared");
const extensions_1 = require("../extensions");
const UserError_1 = require("./UserError");
const ErrorReporter_1 = require("./ErrorReporter");
const NATIVE_IS_SUPPORTED = (0, shared_1.isNativeSupported)();
const moduleFileCache = {};
const JINJA_SYNTAX = /{%|%}|{{|}}/ig;
class DataSchemaCompiler {
    constructor(repository, options = {}) {
        this.repository = repository;
        this.cubeCompilers = options.cubeCompilers || [];
        this.contextCompilers = options.contextCompilers || [];
        this.transpilers = options.transpilers || [];
        this.preTranspileCubeCompilers = options.preTranspileCubeCompilers || [];
        this.cubeNameCompilers = options.cubeNameCompilers || [];
        this.extensions = options.extensions || {};
        this.cubeFactory = options.cubeFactory;
        this.filesToCompile = options.filesToCompile;
        this.omitErrors = options.omitErrors;
        this.allowNodeRequire = options.allowNodeRequire;
        this.compileContext = options.compileContext;
        this.compilerCache = options.compilerCache;
        this.errorReport = options.errorReport;
        this.standalone = options.standalone;
        this.nativeInstance = options.nativeInstance;
        this.yamlCompiler = options.yamlCompiler;
        this.yamlCompiler.dataSchemaCompiler = this;
        this.pythonContext = null;
    }
    compileObjects(compileServices, objects, errorsReport) {
        try {
            return compileServices
                .map((compileService) => (() => compileService.compile(objects, errorsReport)))
                .reduce((p, fn) => p.then(fn), Promise.resolve())
                .catch((error) => {
                errorsReport.error(error);
            });
        }
        catch (e) {
            errorsReport.error(e);
            return Promise.resolve();
        }
    }
    /**
     * @protected
     */
    async loadPythonContext(files, nsFileName) {
        const ns = files.find((f) => f.fileName === nsFileName);
        if (ns) {
            return this.nativeInstance.loadPythonContext(ns.fileName, ns.content);
        }
        return {
            filters: {},
            variables: {},
            functions: {}
        };
    }
    /**
     * @protected
     */
    async doCompile() {
        const files = await this.repository.dataSchemaFiles();
        this.pythonContext = await this.loadPythonContext(files, 'globals.py');
        this.yamlCompiler.initFromPythonContext(this.pythonContext);
        const toCompile = files.filter((f) => !this.filesToCompile || this.filesToCompile.indexOf(f.fileName) !== -1);
        const errorsReport = new ErrorReporter_1.ErrorReporter(null, [], this.errorReport);
        this.errorsReport = errorsReport;
        // TODO: required in order to get pre transpile compilation work
        const transpile = () => toCompile.map(f => this.transpileFile(f, errorsReport)).filter(f => !!f);
        const compilePhase = (compilers) => this.compileCubeFiles(compilers, transpile(), errorsReport);
        return compilePhase({ cubeCompilers: this.cubeNameCompilers })
            .then(() => compilePhase({ cubeCompilers: this.preTranspileCubeCompilers }))
            .then(() => compilePhase({
            cubeCompilers: this.cubeCompilers,
            contextCompilers: this.contextCompilers,
        }));
    }
    compile() {
        if (!this.compilePromise) {
            this.compilePromise = this.doCompile().then((res) => {
                if (!this.omitErrors) {
                    this.throwIfAnyErrors();
                }
                return res;
            });
        }
        return this.compilePromise;
    }
    transpileFile(file, errorsReport) {
        if (ramda_1.default.endsWith('.jinja', file.fileName) ||
            (ramda_1.default.endsWith('.yml', file.fileName) || ramda_1.default.endsWith('.yaml', file.fileName))
                // TODO do Jinja syntax check with jinja compiler
                && file.content.match(JINJA_SYNTAX)) {
            if (NATIVE_IS_SUPPORTED !== true) {
                throw new Error(`Native extension is required to process jinja files. ${NATIVE_IS_SUPPORTED.reason}. Read more: ` +
                    'https://github.com/cube-js/cube/blob/master/packages/cubejs-backend-native/README.md#supported-architectures-and-platforms');
            }
            this.yamlCompiler.getJinjaEngine().loadTemplate(file.fileName, file.content);
            return file;
        }
        else if (ramda_1.default.endsWith('.yml', file.fileName) || ramda_1.default.endsWith('.yaml', file.fileName)) {
            return file;
        }
        else if (ramda_1.default.endsWith('.js', file.fileName)) {
            return this.transpileJsFile(file, errorsReport);
        }
        else {
            return file;
        }
    }
    transpileJsFile(file, errorsReport) {
        try {
            const ast = (0, parser_1.parse)(file.content, {
                sourceFilename: file.fileName,
                sourceType: 'module',
                plugins: ['objectRestSpread']
            });
            this.transpilers.forEach((t) => {
                errorsReport.inFile(file);
                (0, traverse_1.default)(ast, t.traverseObject(errorsReport));
                errorsReport.exitFile();
            });
            const content = (0, generator_1.default)(ast, {}, file.content).code;
            return Object.assign({}, file, { content });
        }
        catch (e) {
            if (e.toString().indexOf('SyntaxError') !== -1) {
                const line = file.content.split('\n')[e.loc.line - 1];
                const spaces = Array(e.loc.column).fill(' ').join('');
                errorsReport.error(`Syntax error during '${file.fileName}' parsing: ${e.message}:\n${line}\n${spaces}^`);
            }
            else {
                errorsReport.error(e);
            }
        }
        return undefined;
    }
    withQuery(query, fn) {
        const oldQuery = this.currentQuery;
        this.currentQuery = query;
        try {
            return fn();
        }
        finally {
            this.currentQuery = oldQuery;
        }
    }
    contextQuery() {
        return this.currentQuery;
    }
    async compileCubeFiles(compilers, toCompile, errorsReport) {
        const cubes = [];
        const exports = {};
        const contexts = [];
        const compiledFiles = {};
        const asyncModules = [];
        toCompile
            .forEach((file) => {
            this.compileFile(file, errorsReport, cubes, exports, contexts, toCompile, compiledFiles, asyncModules);
        });
        await asyncModules.reduce((a, b) => a.then(() => b()), Promise.resolve());
        return this.compileObjects(compilers.cubeCompilers || [], cubes, errorsReport)
            .then(() => this.compileObjects(compilers.contextCompilers || [], contexts, errorsReport));
    }
    throwIfAnyErrors() {
        this.errorsReport.throwIfAny();
    }
    compileFile(file, errorsReport, cubes, exports, contexts, toCompile, compiledFiles, asyncModules) {
        if (compiledFiles[file.fileName]) {
            return;
        }
        compiledFiles[file.fileName] = true;
        if (ramda_1.default.endsWith('.js', file.fileName)) {
            this.compileJsFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles);
        }
        else if (ramda_1.default.endsWith('.yml.jinja', file.fileName) || ramda_1.default.endsWith('.yaml.jinja', file.fileName) ||
            (ramda_1.default.endsWith('.yml', file.fileName) || ramda_1.default.endsWith('.yaml', file.fileName)
            // TODO do Jinja syntax check with jinja compiler
            ) && file.content.match(JINJA_SYNTAX)) {
            asyncModules.push(() => this.yamlCompiler.compileYamlWithJinjaFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles, this.standalone ? {} : this.cloneCompileContextWithGetterAlias(this.compileContext), this.pythonContext));
        }
        else if (ramda_1.default.endsWith('.yml', file.fileName) || ramda_1.default.endsWith('.yaml', file.fileName)) {
            this.yamlCompiler.compileYamlFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles);
        }
    }
    compileJsFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles) {
        const err = (0, syntax_error_1.default)(file.content, file.fileName);
        if (err) {
            errorsReport.error(err.toString());
        }
        try {
            vm_1.default.runInNewContext(file.content, {
                view: (name, cube) => (!cube ?
                    this.cubeFactory({ ...name, fileName: file.fileName, isView: true }) :
                    cubes.push(Object.assign({}, cube, { name, fileName: file.fileName, isView: true }))),
                cube: (name, cube) => (!cube ?
                    this.cubeFactory({ ...name, fileName: file.fileName }) :
                    cubes.push(Object.assign({}, cube, { name, fileName: file.fileName }))),
                context: (name, context) => contexts.push(Object.assign({}, context, { name, fileName: file.fileName })),
                addExport: (obj) => {
                    exports[file.fileName] = exports[file.fileName] || {};
                    exports[file.fileName] = Object.assign(exports[file.fileName], obj);
                },
                setExport: (obj) => {
                    exports[file.fileName] = obj;
                },
                asyncModule: (fn) => {
                    asyncModules.push(fn);
                },
                require: (extensionName) => {
                    if (this.extensions[extensionName]) {
                        return new (this.extensions[extensionName])(this.cubeFactory, this, cubes);
                    }
                    else {
                        const foundFile = this.resolveModuleFile(file, extensionName, toCompile, errorsReport);
                        if (!foundFile && this.allowNodeRequire) {
                            if (extensionName.indexOf('.') === 0) {
                                extensionName = path_1.default.resolve(this.repository.localPath(), extensionName);
                            }
                            // eslint-disable-next-line global-require,import/no-dynamic-require
                            const Extension = require(extensionName);
                            if (Object.getPrototypeOf(Extension).name === 'AbstractExtension') {
                                return new Extension(this.cubeFactory, this, cubes);
                            }
                            return Extension;
                        }
                        this.compileFile(foundFile, errorsReport, cubes, exports, contexts, toCompile, compiledFiles);
                        exports[foundFile.fileName] = exports[foundFile.fileName] || {};
                        return exports[foundFile.fileName];
                    }
                },
                COMPILE_CONTEXT: this.standalone ? this.standaloneCompileContextProxy() : this.cloneCompileContextWithGetterAlias(this.compileContext || {}),
            }, { filename: file.fileName, timeout: 15000 });
        }
        catch (e) {
            errorsReport.error(e);
        }
    }
    // Alias "securityContext" with "security_context" (snake case version)
    // to support snake case based data models
    cloneCompileContextWithGetterAlias(compileContext) {
        const clone = ramda_1.default.clone(compileContext || {});
        clone.security_context = compileContext.securityContext;
        return clone;
    }
    standaloneCompileContextProxy() {
        return new Proxy({}, {
            get: () => {
                throw new UserError_1.UserError('COMPILE_CONTEXT can\'t be used unless contextToAppId is defined. Please see https://cube.dev/docs/config#options-reference-context-to-app-id.');
            }
        });
    }
    resolveModuleFile(currentFile, modulePath, toCompile, errorsReport) {
        const localImport = modulePath.match(/^\.\/(.*)$/);
        if (!currentFile.isModule && localImport) {
            const fileName = localImport[1].match(/^.*\.js$/) ? localImport[1] : `${localImport[1]}.js`;
            const foundFile = toCompile.find((f) => f.fileName === fileName);
            if (!foundFile) {
                throw new UserError_1.UserError(`Required import for ${fileName} is not found`);
            }
            return foundFile;
        }
        const nodeModulesPath = path_1.default.resolve('node_modules');
        let absPath = currentFile.isModule ?
            path_1.default.resolve('node_modules', path_1.default.dirname(currentFile.fileName), modulePath) :
            path_1.default.resolve('node_modules', modulePath);
        if (absPath.indexOf(nodeModulesPath) !== 0) {
            if (this.allowNodeRequire) {
                return null;
            }
            throw new UserError_1.UserError(`'${modulePath}' restricted`);
        }
        const packagePath = absPath.replace(nodeModulesPath, '').split('/').filter(s => !!s)[0];
        if (!packagePath) {
            if (this.allowNodeRequire) {
                return null;
            }
            throw new UserError_1.UserError(`'${modulePath}' is incorrect`);
        }
        if (!this.isWhiteListedPackage(packagePath)) {
            if (this.allowNodeRequire) {
                return null;
            }
            throw new UserError_1.UserError(`Package '${packagePath}' not found`);
        }
        if (fs_1.default.existsSync(absPath)) {
            const stat = fs_1.default.lstatSync(absPath);
            if (stat.isDirectory()) {
                absPath = path_1.default.resolve(absPath, 'index.js');
            }
        }
        // eslint-disable-next-line prefer-template
        absPath = path_1.default.extname(absPath) !== '.js' ? absPath + '.js' : absPath;
        if (!fs_1.default.existsSync(absPath)) {
            if (this.allowNodeRequire) {
                return null;
            }
            // eslint-disable-next-line prefer-template
            throw new UserError_1.UserError(`Path '${absPath.replace(nodeModulesPath + '/', '')}' not found`);
        }
        return this.readModuleFile(absPath, errorsReport);
    }
    readModuleFile(absPath, errorsReport) {
        const nodeModulesPath = path_1.default.resolve('node_modules');
        if (!moduleFileCache[absPath]) {
            const content = fs_1.default.readFileSync(absPath, 'utf-8');
            // eslint-disable-next-line prefer-template
            const fileName = absPath.replace(nodeModulesPath + '/', '');
            const transpiled = this.transpileFile({ fileName, content, isModule: true }, errorsReport);
            if (!transpiled) {
                throw new UserError_1.UserError(`'${fileName}' transpiling failed`);
            }
            moduleFileCache[absPath] = transpiled; // TODO isolated transpiling
        }
        return moduleFileCache[absPath];
    }
    isWhiteListedPackage(packagePath) {
        return packagePath.indexOf('-schema') !== -1 &&
            (packagePath.indexOf('-schema') === packagePath.length - '-schema'.length);
    }
}
exports.DataSchemaCompiler = DataSchemaCompiler;
//# sourceMappingURL=DataSchemaCompiler.js.map