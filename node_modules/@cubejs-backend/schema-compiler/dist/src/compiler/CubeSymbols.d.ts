export class CubeSymbols {
    constructor(evaluateViews: any);
    symbols: {};
    builtCubes: {};
    cubeDefinitions: {};
    funcArgumentsValues: {};
    cubeList: any[];
    evaluateViews: any;
    compile(cubes: any, errorReporter: any): void;
    getCubeDefinition(cubeName: any): any;
    createCube(cubeDefinition: any): any;
    transform(cubeName: any, errorReporter: any, splitViews: any): any;
    /**
     * @private
     */
    private camelCaseTypes;
    transformPreAggregations(preAggregations: any): void;
    transformPreAggregationIndexes(indexes: any): void;
    /**
     * @protected
     */
    protected prepareIncludes(cube: any, errorReporter: any, splitViews: any): void;
    applyIncludeMembers(includeMembers: any, cube: any, type: any, errorReporter: any): void;
    /**
     * @protected
     */
    protected membersFromCubes(parentCube: any, cubes: any, type: any, errorReporter: any, splitViews: any): any[];
    diffByMember(includes: any, excludes: any): any;
    membersFromIncludeExclude(referencesFn: any, cubeName: any, type: any): any[];
    /**
     * @protected
     */
    protected generateIncludeMembers(members: any, cubeName: any, type: any): any;
    evaluateReferences(cube: any, referencesFn: any, options?: {}): any;
    pathFromArray(array: any): any;
    resolveSymbolsCall(func: any, nameResolver: any, context: any): any;
    resolveSymbolsCallContext: any;
    withSymbolsCallContext(func: any, context: any): any;
    funcArguments(func: any): any;
    joinHints(): any;
    resolveSymbol(cubeName: any, name: any): any;
    cubeReferenceProxy(cubeName: any, joinHints: any): any;
    isCurrentCube(name: any): boolean;
}
//# sourceMappingURL=CubeSymbols.d.ts.map