"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YamlCompiler = void 0;
const js_yaml_1 = __importDefault(require("js-yaml"));
const t = __importStar(require("@babel/types"));
const parser_1 = require("@babel/parser");
const generator_1 = __importDefault(require("@babel/generator"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const shared_1 = require("@cubejs-backend/shared");
const transpilers_1 = require("./transpilers");
const PythonParser_1 = require("../parser/PythonParser");
const CubeValidator_1 = require("./CubeValidator");
const utils_1 = require("./utils");
class YamlCompiler {
    constructor(cubeSymbols, cubeDictionary, nativeInstance) {
        this.cubeSymbols = cubeSymbols;
        this.cubeDictionary = cubeDictionary;
        this.nativeInstance = nativeInstance;
        this.dataSchemaCompiler = null;
        this.jinjaEngine = null;
    }
    getJinjaEngine() {
        if (this.jinjaEngine) {
            return this.jinjaEngine;
        }
        throw new Error('Jinja engine was not initialized');
    }
    initFromPythonContext(ctx) {
        this.jinjaEngine = this.nativeInstance.newJinjaEngine({
            debugInfo: (0, shared_1.getEnv)('devMode'),
            filters: ctx.filters,
            workers: 1,
        });
    }
    async compileYamlWithJinjaFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles, compileContext, pythonContext) {
        const compiledFile = {
            fileName: file.fileName,
            content: await this.getJinjaEngine().renderTemplate(file.fileName, compileContext, {
                ...pythonContext.functions,
                ...pythonContext.variables
            }),
        };
        return this.compileYamlFile(compiledFile, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles);
    }
    compileYamlFile(file, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles) {
        if (!file.content.trim()) {
            return;
        }
        const yamlObj = js_yaml_1.default.load(file.content);
        if (!yamlObj) {
            return;
        }
        for (const key of Object.keys(yamlObj)) {
            if (key === 'cubes') {
                (yamlObj.cubes || []).forEach(({ name, ...cube }) => {
                    const transpiledFile = this.transpileAndPrepareJsFile(file, 'cube', { name, ...cube }, errorsReport);
                    this.dataSchemaCompiler?.compileJsFile(transpiledFile, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles);
                });
            }
            else if (key === 'views') {
                (yamlObj.views || []).forEach(({ name, ...cube }) => {
                    const transpiledFile = this.transpileAndPrepareJsFile(file, 'view', { name, ...cube }, errorsReport);
                    this.dataSchemaCompiler?.compileJsFile(transpiledFile, errorsReport, cubes, contexts, exports, asyncModules, toCompile, compiledFiles);
                });
            }
            else {
                errorsReport.error(`Unexpected YAML key: ${key}. Only 'cubes' and 'views' are allowed here.`);
            }
        }
    }
    transpileAndPrepareJsFile(file, methodFn, cubeObj, errorsReport) {
        const yamlAst = this.transformYamlCubeObj(cubeObj, errorsReport);
        const cubeOrViewCall = t.callExpression(t.identifier(methodFn), [t.stringLiteral(cubeObj.name), yamlAst]);
        const content = (0, generator_1.default)(cubeOrViewCall, {}, '').code;
        return {
            fileName: file.fileName,
            content
        };
    }
    transformYamlCubeObj(cubeObj, errorsReport) {
        (0, utils_1.camelizeCube)(cubeObj);
        cubeObj.measures = this.yamlArrayToObj(cubeObj.measures || [], 'measure', errorsReport);
        cubeObj.dimensions = this.yamlArrayToObj(cubeObj.dimensions || [], 'dimension', errorsReport);
        cubeObj.segments = this.yamlArrayToObj(cubeObj.segments || [], 'segment', errorsReport);
        cubeObj.preAggregations = this.yamlArrayToObj(cubeObj.preAggregations || [], 'preAggregation', errorsReport);
        cubeObj.joins = this.yamlArrayToObj(cubeObj.joins || [], 'join', errorsReport);
        return this.transpileYaml(cubeObj, [], cubeObj.name, errorsReport);
    }
    transpileYaml(obj, propertyPath, cubeName, errorsReport) {
        if (transpilers_1.transpiledFields.has(propertyPath[propertyPath.length - 1])) {
            for (const p of transpilers_1.transpiledFieldsPatterns) {
                const fullPath = propertyPath.join('.');
                if (fullPath.match(p)) {
                    if (typeof obj === 'string' && ['sql', 'sqlTable'].includes(propertyPath[propertyPath.length - 1])) {
                        return this.parsePythonIntoArrowFunction(`f"${this.escapeDoubleQuotes(obj)}"`, cubeName, obj, errorsReport);
                    }
                    else if (typeof obj === 'string') {
                        return this.parsePythonIntoArrowFunction(obj, cubeName, obj, errorsReport);
                    }
                    else if (Array.isArray(obj)) {
                        const resultAst = t.program([t.expressionStatement(t.arrayExpression(obj.map(code => {
                                const ast = this.parsePythonAndTranspileToJs(code, errorsReport);
                                return this.extractProgramBodyIfNeeded(ast);
                            }).filter(ast => !!ast)))]);
                        return this.astIntoArrowFunction(resultAst, '', cubeName);
                    }
                }
            }
        }
        if (propertyPath[propertyPath.length - 1] === 'extends') {
            const ast = this.parsePythonAndTranspileToJs(obj, errorsReport);
            return this.astIntoArrowFunction(ast, obj, cubeName, name => this.cubeDictionary.resolveCube(name));
        }
        else if (typeof obj === 'string') {
            let code = obj;
            if (!CubeValidator_1.nonStringFields.has(propertyPath[propertyPath.length - 1])) {
                code = `f"${this.escapeDoubleQuotes(obj)}"`;
            }
            const ast = this.parsePythonAndTranspileToJs(code, errorsReport);
            return this.extractProgramBodyIfNeeded(ast);
        }
        else if (typeof obj === 'boolean') {
            return t.booleanLiteral(obj);
        }
        else if (typeof obj === 'number') {
            return t.numericLiteral(obj);
        }
        else if (obj === null && propertyPath.includes('meta')) {
            return t.nullLiteral();
        }
        if (typeof obj === 'object' && obj !== null) {
            if (Array.isArray(obj)) {
                return t.arrayExpression(obj.map((value, i) => this.transpileYaml(value, propertyPath.concat(i.toString()), cubeName, errorsReport)));
            }
            else {
                const properties = [];
                for (const propKey of Object.keys(obj)) {
                    const ast = this.transpileYaml(obj[propKey], propertyPath.concat(propKey), cubeName, errorsReport);
                    properties.push(t.objectProperty(t.stringLiteral(propKey), ast));
                }
                return t.objectExpression(properties);
            }
        }
        else {
            throw new Error(`Unexpected input during yaml transpiling: ${JSON.stringify(obj)}`);
        }
    }
    escapeDoubleQuotes(str) {
        const result = [];
        const stateStack = [];
        const peek = () => stateStack[stateStack.length - 1] || { inStr: true, inFormattedStr: true };
        for (let i = 0; i < str.length; i++) {
            if (str[i] === 'f' && str[i + 1] === '"' && !peek().inStr) {
                i += 1;
                result.push('f"');
                stateStack.push({ inFormattedStr: true, inStr: true });
            }
            else if (str[i] === '"' && !peek().inStr) {
                result.push('"');
                stateStack.push({ inStr: true });
            }
            else if (str[i] === '"' && stateStack.length === 0) {
                result.push('\\"');
            }
            else if (str[i] === '"' && peek().inStr) {
                result.push(str[i]);
                stateStack.pop();
            }
            else if (str[i] === '`' && stateStack.length === 0) {
                result.push('\\`');
            }
            else if (str[i] === '`' && peek().inStr) {
                result.push(str[i]);
                stateStack.pop();
            }
            else if (str[i] === '{' && str[i + 1] === '{' && peek()?.inFormattedStr) {
                result.push('{{');
                i += 1;
            }
            else if (str[i] === '}' && str[i + 1] === '}' && peek()?.inFormattedStr) {
                result.push('}}');
                i += 1;
            }
            else if (str[i] === '{' && peek()?.inFormattedStr) {
                result.push(str[i]);
                stateStack.push({ inTemplate: true, depth: 1 });
            }
            else if (str[i] === '{' && peek()?.inTemplate) {
                result.push(str[i]);
                const curState = peek();
                curState.depth = (curState.depth || 0) + 1;
            }
            else if (str[i] === '}' && peek()?.inTemplate) {
                result.push(str[i]);
                const curState = peek();
                curState.depth = (curState.depth || 0) - 1;
                if (curState.depth === 0) {
                    stateStack.pop();
                }
            }
            else {
                result.push(str[i]);
            }
        }
        return result.join('');
    }
    parsePythonIntoArrowFunction(codeString, cubeName, originalObj, errorsReport) {
        const ast = this.parsePythonAndTranspileToJs(codeString, errorsReport);
        return this.astIntoArrowFunction(ast, codeString, cubeName);
    }
    parsePythonAndTranspileToJs(codeString, errorsReport) {
        if (codeString === '' || codeString === 'f""') {
            return t.nullLiteral();
        }
        try {
            const pythonParser = new PythonParser_1.PythonParser(codeString);
            return pythonParser.transpileToJs();
        }
        catch (e) {
            errorsReport.error(`Can't parse python expression. Most likely this type of syntax isn't supported yet: ${e.message || e}`);
        }
        return t.nullLiteral();
    }
    astIntoArrowFunction(input, codeString, cubeName, resolveSymbol) {
        const initialJs = (0, generator_1.default)(input, {}, codeString).code;
        // Re-parse generated JS to set all necessary parent paths
        const ast = (0, parser_1.parse)(initialJs, {
            sourceType: 'script',
            plugins: ['objectRestSpread'],
        });
        resolveSymbol = resolveSymbol || (n => this.cubeSymbols.resolveSymbol(cubeName, n) || this.cubeSymbols.isCurrentCube(n));
        const traverseObj = {
            Program: (babelPath) => {
                transpilers_1.CubePropContextTranspiler.replaceValueWithArrowFunction(resolveSymbol, babelPath.get('body')[0].get('expression'));
            },
        };
        (0, traverse_1.default)(ast, traverseObj);
        const body = ast.program.body[0];
        return body?.expression;
    }
    yamlArrayToObj(yamlArray, memberType, errorsReport) {
        if (!Array.isArray(yamlArray)) {
            errorsReport.error(`${memberType}s must be defined as array`);
            return {};
        }
        const remapped = yamlArray.map(({ name, indexes, ...rest }) => {
            if (memberType === 'preAggregation' && indexes) {
                indexes = this.yamlArrayToObj(indexes || [], `${memberType}.index`, errorsReport);
            }
            if (!name) {
                errorsReport.error(`name isn't defined for ${memberType}: ${JSON.stringify(rest)}`);
                return {};
            }
            else if (indexes) {
                return { [name]: { indexes, ...rest } };
            }
            else {
                return { [name]: rest };
            }
        });
        return remapped.reduce((a, b) => ({ ...a, ...b }), {});
    }
    extractProgramBodyIfNeeded(ast) {
        if (t.isProgram(ast)) {
            const body = ast?.body[0];
            return body?.expression;
        }
        return ast;
    }
}
exports.YamlCompiler = YamlCompiler;
//# sourceMappingURL=YamlCompiler.js.map