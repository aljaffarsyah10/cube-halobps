"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeValidator = exports.functionFieldsPatterns = exports.nonStringFields = void 0;
const joi_1 = __importDefault(require("joi"));
const cron_parser_1 = __importDefault(require("cron-parser"));
/* *****************************
 * ATTENTION:
 * In case of adding/removing/changing any Joi.func() field that needs to be transpiled,
 * please run 'cube-validator.test.ts' - transpiledFieldsPatterns
 * and update CubePropContextTranspiler.transpiledFieldsPatterns
 **************************** */
// Update this whenever schema is updated otherwise YAML will be broken
exports.nonStringFields = new Set([
    'primaryKey',
    'scheduledRefresh',
    'unionWithSourceData',
    'rewriteQueries',
    'shown',
    'public',
    'subQuery',
    'propagateFiltersToSubQuery',
    'incremental',
    'external',
    'useOriginalSqlPreAggregations',
    'readOnly',
    'prefix'
]);
const identifierRegex = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
const identifier = joi_1.default.string().regex(identifierRegex, 'identifier');
function formatStatePath(state) {
    if (state.path) {
        // TODO: Remove cast after upgrade of Joi. It show it as string, while it's array
        const path = state.path;
        return path.join('.');
    }
    return '<unknown path>';
}
const regexTimeInterval = joi_1.default.string().custom((value, helper) => {
    if (value.match(/^(-?\d+) (minute|hour|day|week|month|quarter|year)$/)) {
        return value;
    }
    else {
        return helper.message({ custom: `(${formatStatePath(helper.state)} = ${value}) does not match regexp: /^(-?\\d+) (minute|hour|day|week|month|quarter|year)$/` });
    }
});
const timeInterval = joi_1.default.alternatives([
    regexTimeInterval,
    joi_1.default.any().valid('unbounded')
]);
const everyInterval = joi_1.default.string().custom((value, helper) => {
    if (value.match(/^(\d+) (second|minute|hour|day|week)s?$/)) {
        return value;
    }
    else {
        return helper.message({ custom: `(${formatStatePath(helper.state)} = ${value}) does not match regexp: /^(\\d+) (second|minute|hour|day|week)s?$/` });
    }
});
const everyCronInterval = joi_1.default.string().custom((value, helper) => {
    try {
        cron_parser_1.default.parseExpression(value);
        return value;
    }
    catch (e) {
        return helper.message({ custom: `(${formatStatePath(helper.state)} = ${value}) CronParser: ${e.toString()}` });
    }
});
const everyCronTimeZone = joi_1.default.string().custom((value, helper) => {
    try {
        cron_parser_1.default.parseExpression('0 * * * *', { currentDate: '2020-01-01 00:00:01', tz: value });
        return value;
    }
    catch (e) {
        return helper.message({ custom: `(${formatStatePath(helper.state)} = ${value}) unknown timezone. Take a look here https://cube.dev/docs/schema/reference/cube#supported-timezones to get available time zones` });
    }
});
const BaseDimensionWithoutSubQuery = {
    aliases: joi_1.default.array().items(joi_1.default.string()),
    type: joi_1.default.any().valid('string', 'number', 'boolean', 'time', 'geo').required(),
    fieldType: joi_1.default.any().valid('string'),
    valuesAsSegments: joi_1.default.boolean().strict(),
    primaryKey: joi_1.default.boolean().strict(),
    shown: joi_1.default.boolean().strict(),
    public: joi_1.default.boolean().strict(),
    title: joi_1.default.string(),
    description: joi_1.default.string(),
    suggestFilterValues: joi_1.default.boolean().strict(),
    enableSuggestions: joi_1.default.boolean().strict(),
    format: joi_1.default.alternatives([
        joi_1.default.string().valid('imageUrl', 'link', 'currency', 'percent', 'number', 'id'),
        joi_1.default.object().keys({
            type: joi_1.default.string().valid('link'),
            label: joi_1.default.string().required()
        })
    ]),
    meta: joi_1.default.any()
};
const BaseDimension = Object.assign({
    subQuery: joi_1.default.boolean().strict(),
    propagateFiltersToSubQuery: joi_1.default.boolean().strict()
}, BaseDimensionWithoutSubQuery);
const BaseMeasure = {
    aliases: joi_1.default.array().items(joi_1.default.string()),
    format: joi_1.default.any().valid('percent', 'currency', 'number'),
    public: joi_1.default.boolean().strict(),
    // TODO: Deprecate and remove, please use public
    visible: joi_1.default.boolean().strict(),
    // TODO: Deprecate and remove, please use public
    shown: joi_1.default.boolean().strict(),
    cumulative: joi_1.default.boolean().strict(),
    filters: joi_1.default.array().items(joi_1.default.object().keys({
        sql: joi_1.default.func().required()
    })),
    title: joi_1.default.string(),
    description: joi_1.default.string(),
    rollingWindow: joi_1.default.object().keys({
        trailing: timeInterval,
        leading: timeInterval,
        offset: joi_1.default.any().valid('start', 'end')
    }),
    drillMemberReferences: joi_1.default.func(),
    drillMembers: joi_1.default.func(),
    drillFilters: joi_1.default.array().items(joi_1.default.object().keys({
        sql: joi_1.default.func().required()
    })),
    meta: joi_1.default.any()
};
function condition(fun, then, otherwise) {
    return joi_1.default.alternatives().conditional(joi_1.default.ref('.'), {
        is: joi_1.default.custom((value, helper) => (fun(value) ? value : helper.message({}))),
        then,
        otherwise
    });
}
function defined(a) {
    return typeof a !== 'undefined';
}
function inherit(a, b) {
    return joi_1.default.object().keys(Object.assign({}, a, b));
}
function requireOneOf(...keys) {
    return joi_1.default.alternatives().try(...(keys.map((k) => joi_1.default.object().keys({ [k]: joi_1.default.exist().required() }))));
}
const PreAggregationRefreshKeySchema = condition((s) => defined(s.sql), joi_1.default.object().keys({
    sql: joi_1.default.func().required(),
    // We dont support timezone for this, because it's useless
    // We cannot support cron interval
    every: everyInterval,
}), condition((s) => defined(s.every), joi_1.default.object().keys({
    every: joi_1.default.alternatives().try(everyInterval, everyCronInterval),
    timezone: everyCronTimeZone,
    incremental: joi_1.default.boolean().strict(),
    updateWindow: everyInterval
}), requireOneOf('sql', 'every')));
const BasePreAggregationWithoutPartitionGranularity = {
    refreshKey: PreAggregationRefreshKeySchema,
    sqlAlias: joi_1.default.string().optional(),
    useOriginalSqlPreAggregations: joi_1.default.boolean().strict(),
    external: joi_1.default.boolean().strict(),
    scheduledRefresh: joi_1.default.boolean().strict(),
    indexes: joi_1.default.object().pattern(identifierRegex, joi_1.default.alternatives().try(joi_1.default.object().keys({
        sql: joi_1.default.func().required()
    }), joi_1.default.object().keys({
        columns: joi_1.default.func().required(),
        type: joi_1.default.any().valid('regular', 'aggregate'),
    }))),
    // refreshRange was deprecated
    refreshRangeStart: {
        sql: joi_1.default.func().required()
    },
    refreshRangeEnd: {
        sql: joi_1.default.func().required()
    },
    // new api
    buildRangeStart: {
        sql: joi_1.default.func().required()
    },
    buildRangeEnd: {
        sql: joi_1.default.func().required()
    },
    readOnly: joi_1.default.boolean().strict(),
    streamOffset: joi_1.default.any().valid('earliest', 'latest'),
};
const BasePreAggregation = {
    ...BasePreAggregationWithoutPartitionGranularity,
    partitionGranularity: joi_1.default.any().valid('hour', 'day', 'week', 'month', 'quarter', 'year'),
};
const AutoRollupSchema = inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('autoRollup').required(),
    maxPreAggregations: joi_1.default.number(),
});
const OriginalSqlSchema = condition((s) => defined(s.partitionGranularity) || defined(s.timeDimension) || defined(s.timeDimensionReference), condition((s) => defined(s.timeDimensionReference), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('originalSql').required(),
    uniqueKeyColumns: joi_1.default.array().items(joi_1.default.string()),
    partitionGranularity: BasePreAggregation.partitionGranularity.required(),
    timeDimensionReference: joi_1.default.func().required(),
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
}), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('originalSql').required(),
    uniqueKeyColumns: joi_1.default.array().items(joi_1.default.string()),
    partitionGranularity: BasePreAggregation.partitionGranularity.required(),
    timeDimension: joi_1.default.func().required(),
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
})), inherit(BasePreAggregationWithoutPartitionGranularity, {
    type: joi_1.default.any().valid('originalSql').required(),
    uniqueKeyColumns: joi_1.default.array().items(joi_1.default.string())
}));
const GranularitySchema = joi_1.default.string().valid('second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year').required();
const ReferencesFields = ['timeDimensionReference', 'rollupReferences', 'measureReferences', 'dimensionReferences', 'segmentReferences'];
const NonReferencesFields = ['timeDimension', 'rollups', 'measures', 'dimensions', 'segments'];
function hasAnyField(fields, s) {
    return !fields.every((f) => !defined(s[f]));
}
function errorOnMixing(schema) {
    return condition((s) => hasAnyField(ReferencesFields, s) && hasAnyField(NonReferencesFields, s), joi_1.default.any().forbidden().error(new Error(`[${ReferencesFields.join(', ')}] are deprecated, please, use [${NonReferencesFields.join(', ')}] instead`)), schema);
}
const RollUpJoinSchema = condition((s) => defined(s.granularity) || defined(s.timeDimension) || defined(s.timeDimensionReference), condition((s) => defined(s.rollupReferences) || defined(s.timeDimensionReference), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollupJoin').required(),
    scheduledRefresh: joi_1.default.boolean().valid(false),
    granularity: GranularitySchema,
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
    timeDimensionReference: joi_1.default.func().required(),
    rollupReferences: joi_1.default.func().required(),
    measureReferences: joi_1.default.func(),
    dimensionReferences: joi_1.default.func(),
    segmentReferences: joi_1.default.func(),
}), 
// RollupJoin without references
inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollupJoin').required(),
    scheduledRefresh: joi_1.default.boolean().valid(false),
    granularity: GranularitySchema,
    timeDimension: joi_1.default.func().required(),
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
    rollups: joi_1.default.func().required(),
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func(),
})), condition((s) => defined(s.rollupReferences), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollupJoin').required(),
    scheduledRefresh: joi_1.default.boolean().valid(false),
    rollupReferences: joi_1.default.func().required(),
    measureReferences: joi_1.default.func(),
    dimensionReferences: joi_1.default.func(),
    segmentReferences: joi_1.default.func(),
}), 
// RollupJoin without references
condition((s) => defined(s.rollups), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollupJoin').required(),
    scheduledRefresh: joi_1.default.boolean().valid(false),
    rollups: joi_1.default.func().required(),
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func(),
}), requireOneOf('granularity', 'rollups', 'timeDimension'))));
const RollupLambdaSchema = condition((s) => defined(s.granularity) || defined(s.timeDimension), {
    type: joi_1.default.any().valid('rollupLambda').required(),
    granularity: GranularitySchema,
    timeDimension: joi_1.default.func().required(),
    rollups: joi_1.default.func().required(),
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func(),
    unionWithSourceData: joi_1.default.boolean().strict(),
}, {
    type: joi_1.default.any().valid('rollupLambda').required(),
    rollups: joi_1.default.func().required(),
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func(),
    unionWithSourceData: joi_1.default.boolean().strict(),
});
const RollUpSchema = condition((s) => defined(s.granularity) || defined(s.timeDimension) || defined(s.timeDimensionReference), condition((s) => defined(s.timeDimensionReference), inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollup').required(),
    timeDimensionReference: joi_1.default.func().required(),
    granularity: GranularitySchema,
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
    measureReferences: joi_1.default.func(),
    dimensionReferences: joi_1.default.func(),
    segmentReferences: joi_1.default.func(),
}), 
// Rollup without References postfix
inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollup').required(),
    timeDimension: joi_1.default.func().required(),
    allowNonStrictDateRangeMatch: joi_1.default.bool(),
    granularity: GranularitySchema,
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func(),
})), joi_1.default.alternatives().try(inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollup').required(),
    measureReferences: joi_1.default.func(),
    dimensionReferences: joi_1.default.func(),
    segmentReferences: joi_1.default.func()
}), 
// Rollup without References postfix
inherit(BasePreAggregation, {
    type: joi_1.default.any().valid('rollup').required(),
    measures: joi_1.default.func(),
    dimensions: joi_1.default.func(),
    segments: joi_1.default.func()
})));
const PreAggregationsAlternatives = joi_1.default.object().pattern(identifierRegex, errorOnMixing(joi_1.default.alternatives().conditional(joi_1.default.ref('.type'), [
    { is: 'autoRollup', then: AutoRollupSchema },
    { is: 'originalSql', then: OriginalSqlSchema },
    { is: 'rollupJoin', then: RollUpJoinSchema },
    { is: 'rollupLambda', then: RollupLambdaSchema },
    { is: 'rollup',
        then: RollUpSchema,
        otherwise: joi_1.default.object().keys({
            type: joi_1.default.string().valid('autoRollup', 'originalSql', 'rollupJoin', 'rollup').required()
        })
    }
])));
const CubeRefreshKeySchema = condition((s) => defined(s.every), condition((s) => defined(s.sql), joi_1.default.object().keys({
    sql: joi_1.default.func().required(),
    // We dont support timezone for this, because it's useless
    // We cannot support cron interval
    every: everyInterval,
}), joi_1.default.object().keys({
    every: joi_1.default.alternatives().try(everyInterval, everyCronInterval).required(),
    timezone: everyCronTimeZone,
})), condition((s) => defined(s.immutable), joi_1.default.object().keys({
    immutable: joi_1.default.boolean().strict().required()
}), requireOneOf('every', 'sql', 'immutable')));
const measureType = joi_1.default.string().valid('number', 'string', 'boolean', 'time', 'sum', 'avg', 'min', 'max', 'countDistinct', 'runningTotal', 'countDistinctApprox');
const measureTypeWithCount = joi_1.default.string().valid('count', 'number', 'string', 'boolean', 'time', 'sum', 'avg', 'min', 'max', 'countDistinct', 'runningTotal', 'countDistinctApprox');
const MeasuresSchema = joi_1.default.object().pattern(identifierRegex, joi_1.default.alternatives().conditional(joi_1.default.ref('.type'), [
    {
        is: 'count',
        then: inherit(BaseMeasure, {
            type: joi_1.default.any().valid('count').required(),
            sql: joi_1.default.func(),
        })
    },
    {
        is: measureType,
        then: inherit(BaseMeasure, {
            sql: joi_1.default.func().required(),
            type: measureType.required()
        }),
        otherwise: joi_1.default.object().keys({
            type: measureTypeWithCount.required()
        })
    }
]));
const SegmentsSchema = joi_1.default.object().pattern(identifierRegex, joi_1.default.object().keys({
    aliases: joi_1.default.array().items(joi_1.default.string()),
    sql: joi_1.default.func().required(),
    title: joi_1.default.string(),
    description: joi_1.default.string(),
    meta: joi_1.default.any(),
    shown: joi_1.default.boolean().strict(),
    public: joi_1.default.boolean().strict(),
}));
/* *****************************
 * ATTENTION:
 * In case of adding/removing/changing any Joi.func() field that needs to be transpiled,
 * please run 'cube-validator.test.ts' - transpiledFieldsPatterns
 * and update CubePropContextTranspiler.transpiledFieldsPatterns
 **************************** */
const baseSchema = {
    name: identifier,
    refreshKey: CubeRefreshKeySchema,
    fileName: joi_1.default.string().required(),
    extends: joi_1.default.func(),
    allDefinitions: joi_1.default.func(),
    title: joi_1.default.string(),
    sqlAlias: joi_1.default.string(),
    dataSource: joi_1.default.string(),
    description: joi_1.default.string(),
    rewriteQueries: joi_1.default.boolean().strict(),
    shown: joi_1.default.boolean().strict(),
    public: joi_1.default.boolean().strict(),
    meta: joi_1.default.any(),
    joins: joi_1.default.object().pattern(identifierRegex, joi_1.default.object().keys({
        sql: joi_1.default.func().required(),
        relationship: joi_1.default.any().valid('belongsTo', 'belongs_to', 'many_to_one', 'manyToOne', 'hasMany', 'has_many', 'one_to_many', 'oneToMany', 'hasOne', 'has_one', 'one_to_one', 'oneToOne').required()
    })),
    measures: MeasuresSchema,
    dimensions: joi_1.default.object().pattern(identifierRegex, joi_1.default.alternatives().try(inherit(BaseDimensionWithoutSubQuery, {
        case: joi_1.default.object().keys({
            when: joi_1.default.array().items(joi_1.default.object().keys({
                sql: joi_1.default.func().required(),
                label: joi_1.default.alternatives([
                    joi_1.default.string(),
                    joi_1.default.object().keys({
                        sql: joi_1.default.func().required()
                    })
                ])
            })),
            else: joi_1.default.object().keys({
                label: joi_1.default.alternatives([
                    joi_1.default.string(),
                    joi_1.default.object().keys({
                        sql: joi_1.default.func().required()
                    })
                ])
            })
        }).required()
    }), inherit(BaseDimensionWithoutSubQuery, {
        latitude: joi_1.default.object().keys({
            sql: joi_1.default.func().required()
        }).required(),
        longitude: joi_1.default.object().keys({
            sql: joi_1.default.func().required()
        }).required()
    }), inherit(BaseDimension, {
        sql: joi_1.default.func().required()
    }))),
    segments: SegmentsSchema,
    preAggregations: PreAggregationsAlternatives,
};
const cubeSchema = inherit(baseSchema, {
    sql: joi_1.default.func(),
    sqlTable: joi_1.default.func(),
}).xor('sql', 'sqlTable').messages({
    'object.xor': 'You must use either sql or sqlTable within a model, but not both'
});
const viewSchema = inherit(baseSchema, {
    isView: joi_1.default.boolean().strict(),
    includes: joi_1.default.func(),
    excludes: joi_1.default.func(),
    cubes: joi_1.default.array().items(joi_1.default.object().keys({
        joinPath: joi_1.default.func().required(),
        prefix: joi_1.default.boolean(),
        split: joi_1.default.boolean(),
        alias: joi_1.default.string(),
        includes: joi_1.default.alternatives([
            joi_1.default.string().valid('*'),
            joi_1.default.array().items(joi_1.default.alternatives([
                joi_1.default.string().required(),
                joi_1.default.object().keys({
                    name: joi_1.default.string().required(),
                    alias: joi_1.default.string()
                })
            ]))
        ]).required(),
        excludes: joi_1.default.array().items(joi_1.default.string().required()),
    }).oxor('split', 'prefix').messages({
        'object.oxor': 'Using split together with prefix is not supported'
    })),
});
function formatErrorMessageFromDetails(explain, d) {
    if (d?.context?.details) {
        d?.context?.details?.forEach((d2) => formatErrorMessageFromDetails(explain, d2));
    }
    else if (d?.message) {
        const key = d?.context?.message || d?.message;
        const val = key?.replace(`"${d.context?.label}"`, `(${d.context?.label} = ${d.context?.value})`);
        explain.set(key, val);
    }
}
function formatErrorMessage(error) {
    const explain = new Map();
    explain.set(error.message, error.message);
    error?.details?.forEach((d) => formatErrorMessageFromDetails(explain, d));
    const messages = Array.from(explain.values());
    let message = messages.shift();
    if (messages.length > 0) {
        message += `\nPossible reasons (one of):\n\t* ${messages.join('\n\t* ')}`;
    }
    return message.replace(/ = undefined\) is required/g, ') is required');
}
function collectFunctionFieldsPatterns(patterns, path, o) {
    let key = o?.id || o?.key || ((o?.patterns?.length || 0) > 0 ? '*' : undefined);
    if (o?.schema?.type === 'array' && key && typeof key === 'string') {
        key = `${key}.0`;
    }
    // eslint-disable-next-line no-nested-ternary
    const newPath = key && typeof key === 'string' ? (path.length > 0 ? `${path}.${key}` : key) : path;
    if (o?.schema?.type === 'function') {
        patterns.add(newPath);
        return;
    }
    if (Array.isArray(o)) {
        o.forEach((v) => collectFunctionFieldsPatterns(patterns, newPath, v));
    }
    else if (o instanceof Map) {
        o.forEach((v, k) => collectFunctionFieldsPatterns(patterns, newPath, v));
    }
    else if (o === Object(o)) {
        // eslint-disable-next-line no-restricted-syntax
        for (const k in o) {
            if (k !== '$_root' && o.hasOwnProperty(k))
                collectFunctionFieldsPatterns(patterns, newPath, o[k]);
        }
    }
}
function functionFieldsPatterns() {
    const functionPatterns = new Set();
    collectFunctionFieldsPatterns(functionPatterns, '', { ...cubeSchema, ...viewSchema });
    return Array.from(functionPatterns);
}
exports.functionFieldsPatterns = functionFieldsPatterns;
class CubeValidator {
    constructor(cubeSymbols) {
        this.cubeSymbols = cubeSymbols;
        this.validCubes = new Map();
    }
    compile(cubes, errorReporter) {
        return this.cubeSymbols.cubeList.map((v) => this.validate(this.cubeSymbols.getCubeDefinition(v.name), errorReporter.inContext(`${v.name} cube`)));
    }
    validate(cube, errorReporter) {
        const result = cube.isView ? viewSchema.validate(cube) : cubeSchema.validate(cube);
        if (result.error != null) {
            errorReporter.error(formatErrorMessage(result.error), result.error);
        }
        else {
            this.validCubes[cube.name] = true;
        }
        return result;
    }
    isCubeValid(cube) {
        return this.validCubes[cube.name] || cube.isSplitView;
    }
}
exports.CubeValidator = CubeValidator;
//# sourceMappingURL=CubeValidator.js.map