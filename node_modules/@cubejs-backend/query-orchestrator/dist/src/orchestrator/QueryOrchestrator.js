"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryOrchestrator = exports.DriverType = void 0;
const ramda_1 = __importDefault(require("ramda"));
const shared_1 = require("@cubejs-backend/shared");
const cubestore_driver_1 = require("@cubejs-backend/cubestore-driver");
const QueryCache_1 = require("./QueryCache");
const PreAggregations_1 = require("./PreAggregations");
const RedisPool_1 = require("./RedisPool");
const RedisQueueEventsBus_1 = require("./RedisQueueEventsBus");
const LocalQueueEventsBus_1 = require("./LocalQueueEventsBus");
const QueryStream_1 = require("./QueryStream");
var DriverType;
(function (DriverType) {
    DriverType["External"] = "external";
    DriverType["Internal"] = "internal";
    DriverType["Cache"] = "cache";
})(DriverType || (exports.DriverType = DriverType = {}));
let redisDeprecationShowed = false;
function detectQueueAndCacheDriver(options) {
    if (options.cacheAndQueueDriver) {
        return options.cacheAndQueueDriver;
    }
    const cacheAndQueueDriver = (0, shared_1.getEnv)('cacheAndQueueDriver');
    if (cacheAndQueueDriver) {
        return cacheAndQueueDriver;
    }
    if ((0, shared_1.getEnv)('redisUrl') || (0, shared_1.getEnv)('redisUseIORedis')) {
        return 'redis';
    }
    if ((0, shared_1.getEnv)('nodeEnv') === 'production') {
        return 'cubestore';
    }
    return 'memory';
}
class QueryOrchestrator {
    constructor(redisPrefix, driverFactory, logger, options = {}) {
        this.redisPrefix = redisPrefix;
        this.driverFactory = driverFactory;
        this.logger = logger;
        this.rollupOnlyMode = options.rollupOnlyMode;
        const cacheAndQueueDriver = detectQueueAndCacheDriver(options);
        if (!['redis', 'memory', 'cubestore'].includes(cacheAndQueueDriver)) {
            throw new Error(`Only 'cubestore', 'redis' or 'memory' are supported for cacheAndQueueDriver option, passed: ${cacheAndQueueDriver}`);
        }
        if (cacheAndQueueDriver === 'redis' && !redisDeprecationShowed) {
            this.logger('Redis Deprecation', {
                warning: ('Redis queue and cache driver is deprecated and no longer supported. Please consider switching to cubestore option.')
            });
            redisDeprecationShowed = true;
        }
        const { externalDriverFactory, continueWaitTimeout, skipExternalCacheAndQueue } = options;
        const redisPool = cacheAndQueueDriver === 'redis' ? new RedisPool_1.RedisPool(options.redisPoolOptions) : undefined;
        this.redisPool = redisPool;
        this.cacheAndQueueDriver = cacheAndQueueDriver;
        const cubeStoreDriverFactory = cacheAndQueueDriver === 'cubestore' ? async () => {
            if (externalDriverFactory) {
                const externalDriver = await externalDriverFactory();
                if (externalDriver instanceof cubestore_driver_1.CubeStoreDriver) {
                    return externalDriver;
                }
                throw new Error('It`s not possible to use Cube Store as queue/cache driver without using it as external');
            }
            throw new Error('Cube Store was specified as queue/cache driver. Please set CUBEJS_CUBESTORE_HOST and CUBEJS_CUBESTORE_PORT variables. Please see https://cube.dev/docs/deployment/production-checklist#set-up-cube-store to learn more.');
        } : undefined;
        this.queryCache = new QueryCache_1.QueryCache(this.redisPrefix, driverFactory, this.logger, {
            externalDriverFactory,
            cacheAndQueueDriver,
            redisPool,
            cubeStoreDriverFactory,
            continueWaitTimeout,
            skipExternalCacheAndQueue,
            ...options.queryCacheOptions,
        });
        this.preAggregations = new PreAggregations_1.PreAggregations(this.redisPrefix, this.driverFactory, this.logger, this.queryCache, {
            externalDriverFactory,
            cacheAndQueueDriver,
            redisPool,
            cubeStoreDriverFactory,
            continueWaitTimeout,
            skipExternalCacheAndQueue,
            ...options.preAggregationsOptions,
            getQueueEventsBus: (0, shared_1.getEnv)('preAggregationsQueueEventsBus') &&
                this.getQueueEventsBus.bind(this)
        });
    }
    getQueueEventsBus() {
        if (!this.queueEventsBus) {
            const isRedis = this.cacheAndQueueDriver === 'redis';
            this.queueEventsBus = isRedis ?
                new RedisQueueEventsBus_1.RedisQueueEventsBus({ redisPool: this.redisPool }) :
                new LocalQueueEventsBus_1.LocalQueueEventsBus();
        }
        return this.queueEventsBus;
    }
    /**
     * Returns QueryCache instance.
     */
    getQueryCache() {
        return this.queryCache;
    }
    /**
     * Returns PreAggregations instance.
     */
    getPreAggregations() {
        return this.preAggregations;
    }
    /**
     * Force reconcile queue logic to be executed.
     */
    async forceReconcile(datasource = 'default') {
        // pre-aggregations queue reconcile
        const preaggsQueue = await this.preAggregations.getQueue(datasource);
        if (preaggsQueue) {
            await preaggsQueue.reconcileQueue();
        }
        // queries queue reconcile
        const queryQueue = await this.queryCache.getQueue(datasource);
        if (queryQueue) {
            await queryQueue.reconcileQueue();
        }
    }
    /**
     * Determines whether the partition table is already exists or not.
     */
    async isPartitionExist(request, external, dataSource = 'default', schema, table, key, token) {
        return this.preAggregations.isPartitionExist(request, external, dataSource, schema, table, key, token);
    }
    /**
     * Returns stream object which will be used to stream results from
     * the data source if applicable. Throw otherwise.
     *
     * @throw Error
     */
    async streamQuery(query) {
        const { preAggregationsTablesToTempTables, values, } = await this.preAggregations.loadAllPreAggregationsIfNeeded(query);
        query.values = values || query.values;
        const _stream = await this.queryCache.cachedQueryResult(query, preAggregationsTablesToTempTables);
        return _stream;
    }
    /**
     * Push query to the queue, fetch and return result if query takes
     * less than `continueWaitTimeout` seconds, throw `ContinueWaitError`
     * error otherwise.
     *
     * @throw ContinueWaitError
     */
    async fetchQuery(queryBody) {
        const { preAggregationsTablesToTempTables, values, } = await this.preAggregations.loadAllPreAggregationsIfNeeded(queryBody);
        if (values) {
            queryBody = {
                ...queryBody,
                values
            };
        }
        const usedPreAggregations = ramda_1.default.pipe(ramda_1.default.fromPairs, ramda_1.default.map((pa) => ({
            targetTableName: pa.targetTableName,
            refreshKeyValues: pa.refreshKeyValues,
            lastUpdatedAt: pa.lastUpdatedAt,
        })))(preAggregationsTablesToTempTables);
        if (this.rollupOnlyMode && Object.keys(usedPreAggregations).length === 0) {
            throw new Error('No pre-aggregation table has been built for this query yet. ' +
                'Please check your refresh worker configuration if it persists.');
        }
        let lastRefreshTimestamp = (0, PreAggregations_1.getLastUpdatedAtTimestamp)(preAggregationsTablesToTempTables.map(pa => pa[1].lastUpdatedAt));
        if (!queryBody.query) {
            // We want to return a more convenient and filled object for the following
            // processing for a jobed build query (initialized by the
            // /cubejs-system/v1/pre-aggregations/jobs endpoint).
            if (queryBody.isJob) {
                return preAggregationsTablesToTempTables.map((pa) => ({
                    preAggregation: queryBody.preAggregations[0].preAggregationId,
                    tableName: pa[0],
                    ...pa[1],
                }));
            }
            else {
                return {
                    usedPreAggregations,
                    lastRefreshTime: lastRefreshTimestamp && new Date(lastRefreshTimestamp),
                };
            }
        }
        const result = await this.queryCache.cachedQueryResult(queryBody, preAggregationsTablesToTempTables);
        lastRefreshTimestamp = (0, PreAggregations_1.getLastUpdatedAtTimestamp)([
            lastRefreshTimestamp,
            result.lastRefreshTime?.getTime()
        ]);
        if (result instanceof QueryStream_1.QueryStream) {
            // TODO do some wrapper object to provide metadata?
            return result;
        }
        return {
            ...result,
            dataSource: queryBody.dataSource,
            external: queryBody.external,
            usedPreAggregations,
            lastRefreshTime: lastRefreshTimestamp && new Date(lastRefreshTimestamp),
        };
    }
    async loadRefreshKeys(query) {
        return this.queryCache.loadRefreshKeysFromQuery(query);
    }
    async queryStage(queryBody) {
        const preAggregationsQueryStageStateByDataSource = {};
        const preAggregationsQueryStageState = async (dataSource) => {
            if (!preAggregationsQueryStageStateByDataSource[dataSource]) {
                const queue = await this.preAggregations.getQueue(dataSource);
                preAggregationsQueryStageStateByDataSource[dataSource] = queue.fetchQueryStageState();
            }
            return preAggregationsQueryStageStateByDataSource[dataSource];
        };
        const pendingPreAggregationIndex = (await Promise.all((queryBody.preAggregations || [])
            .map(async (p) => {
            const queue = await this.preAggregations.getQueue(p.dataSource);
            return queue.getQueryStage(PreAggregations_1.PreAggregations.preAggregationQueryCacheKey(p), 10, await preAggregationsQueryStageState(p.dataSource));
        }))).findIndex(p => !!p);
        if (pendingPreAggregationIndex === -1) {
            const qcQueue = await this.queryCache.getQueue(queryBody.dataSource);
            return qcQueue.getQueryStage(QueryCache_1.QueryCache.queryCacheKey(queryBody));
        }
        const preAggregation = queryBody.preAggregations[pendingPreAggregationIndex];
        const paQueue = await this.preAggregations.getQueue(preAggregation.dataSource);
        const preAggregationStage = await paQueue.getQueryStage(PreAggregations_1.PreAggregations.preAggregationQueryCacheKey(preAggregation), undefined, await preAggregationsQueryStageState(preAggregation.dataSource));
        if (!preAggregationStage) {
            return undefined;
        }
        const stageMessage = `Building pre-aggregation ${pendingPreAggregationIndex + 1}/${queryBody.preAggregations.length}`;
        if (preAggregationStage.stage.indexOf('queue') !== -1) {
            return { ...preAggregationStage, stage: `${stageMessage}: ${preAggregationStage.stage}` };
        }
        else {
            return { ...preAggregationStage, stage: stageMessage };
        }
    }
    resultFromCacheIfExists(queryBody) {
        return this.queryCache.resultFromCacheIfExists(queryBody);
    }
    async testConnections() {
        // @todo Possible, We will allow to use different drivers for cache and queue, dont forget to add both
        try {
            await this.queryCache.testConnection();
        }
        catch (e) {
            e.driverType = DriverType.Cache;
            throw e;
        }
    }
    async cleanup() {
        return this.queryCache.cleanup();
    }
    async getPreAggregationVersionEntries(preAggregations, preAggregationsSchema, requestId) {
        const versionEntries = await this.preAggregations.getVersionEntries(preAggregations.map(p => {
            const { preAggregation } = p.preAggregation;
            const partition = p.partitions[0];
            preAggregation.dataSource = (partition && partition.dataSource) || 'default';
            preAggregation.preAggregationsSchema = preAggregationsSchema;
            return preAggregation;
        }), requestId);
        const flatFn = (arrResult, arrItem) => ([...arrResult, ...arrItem]);
        const structureVersionsByTableName = preAggregations
            .map(p => p.partitions)
            .reduce(flatFn, [])
            .reduce((obj, partition) => {
            if (partition) {
                obj[partition.tableName] = PreAggregations_1.PreAggregations.structureVersion(partition);
            }
            return obj;
        }, {});
        return {
            structureVersionsByTableName,
            versionEntriesByTableName: versionEntries
                .reduce(flatFn, [])
                .filter((versionEntry) => {
                const structureVersion = structureVersionsByTableName[versionEntry.table_name];
                return structureVersion && versionEntry.structure_version === structureVersion;
            })
                .reduce((obj, versionEntry) => {
                if (!obj[versionEntry.table_name])
                    obj[versionEntry.table_name] = [];
                obj[versionEntry.table_name].push(versionEntry);
                return obj;
            }, {})
        };
    }
    async getPreAggregationPreview(requestId, preAggregation) {
        if (!preAggregation)
            return [];
        const [query] = preAggregation.previewSql;
        const { external } = preAggregation;
        const data = await this.fetchQuery({
            continueWait: true,
            query,
            external,
            preAggregations: [
                preAggregation
            ],
            requestId,
        });
        return data || [];
    }
    async expandPartitionsInPreAggregations(queryBody) {
        return this.preAggregations.expandPartitionsInPreAggregations(queryBody);
    }
    async checkPartitionsBuildRangeCache(queryBody) {
        return this.preAggregations.checkPartitionsBuildRangeCache(queryBody);
    }
    async getPreAggregationQueueStates(dataSource = 'default') {
        return this.preAggregations.getQueueState(dataSource);
    }
    async cancelPreAggregationQueriesFromQueue(queryKeys, dataSource = 'default') {
        return this.preAggregations.cancelQueriesFromQueue(queryKeys, dataSource);
    }
    async subscribeQueueEvents(id, callback) {
        return this.getQueueEventsBus().subscribe(id, callback);
    }
    async unSubscribeQueueEvents(id) {
        return this.getQueueEventsBus().unsubscribe(id);
    }
    async updateRefreshEndReached() {
        return this.preAggregations.updateRefreshEndReached();
    }
}
exports.QueryOrchestrator = QueryOrchestrator;
//# sourceMappingURL=QueryOrchestrator.js.map