import { DownloadTableData, DriverCapabilities, DriverInterface, InlineTable, SaveCancelFn, StreamOptions, TableStructure, UnloadOptions } from '@cubejs-backend/base-driver';
import { CubeStoreDriver } from '@cubejs-backend/cubestore-driver';
import { PreAggTableToTempTable, Query, QueryBody, QueryCache, QueryTuple, QueryWithParams } from './QueryCache';
import { DriverFactory, DriverFactoryByDataSource } from './DriverFactory';
import { QueryQueue } from './QueryQueue';
import { CacheAndQueryDriverType } from './QueryOrchestrator';
import { RedisPool } from './RedisPool';
export declare const LAMBDA_TABLE_PREFIX = "lambda";
export declare function getLastUpdatedAtTimestamp(timestamps: (number | undefined)[]): number | undefined;
type VersionEntry = {
    'table_name': string;
    'content_version': string;
    'structure_version': string;
    'last_updated_at': number;
    'build_range_end'?: string;
    'naming_version'?: number;
};
type IndexesSql = {
    sql: [string, unknown[]];
    indexName: string;
}[];
type InvalidationKeys = unknown[];
type QueryKey = [QueryTuple, IndexesSql, InvalidationKeys] | [QueryTuple, InvalidationKeys];
type QueryOptions = {
    queryKey: QueryKey;
    newVersionEntry: VersionEntry;
    query: string;
    values: unknown[];
    requestId: string;
    buildRangeEnd?: string;
};
type TableCacheEntry = {
    table_name?: string;
    TABLE_NAME?: string;
    build_range_end?: string;
};
type QueryDateRange = [string, string];
type IndexDescription = {
    sql: QueryWithParams;
    indexName: string;
};
export type LambdaOptions = {
    maxSourceRows: number;
};
export type LambdaQuery = {
    sqlAndParams: QueryWithParams;
    cacheKeyQueries: any[];
};
export type PreAggregationDescription = {
    preAggregationsSchema: string;
    type: 'rollup' | 'originalSql';
    preAggregationId: string;
    priority: number;
    dataSource: string;
    external: boolean;
    previewSql: QueryWithParams;
    timezone: string;
    indexesSql: IndexDescription[];
    invalidateKeyQueries: QueryWithParams[];
    partitionInvalidateKeyQueries: QueryWithParams[];
    structureVersionLoadSql: QueryWithParams;
    sql: QueryWithParams;
    loadSql: QueryWithParams;
    tableName: string;
    matchedTimeDimensionDateRange: QueryDateRange;
    granularity: string;
    partitionGranularity: string;
    preAggregationStartEndQueries: [QueryWithParams, QueryWithParams];
    timestampFormat: string;
    expandedPartition: boolean;
    unionWithSourceData: LambdaOptions;
    buildRangeEnd?: string;
    updateWindowSeconds?: number;
    sealAt?: string;
    rollupLambdaId?: string;
    lastRollupLambda?: boolean;
};
type PreAggregationLoadCacheOptions = {
    requestId?: string;
    dataSource: string;
    tablePrefixes?: string[];
};
type VersionEntriesObj = {
    versionEntries: VersionEntry[];
    byStructure: {
        [key: string]: VersionEntry;
    };
    byContent: {
        [key: string]: VersionEntry;
    };
    byTableName: {
        [key: string]: VersionEntry;
    };
};
declare class PreAggregationLoadCache {
    private redisPrefix;
    private driverFactory;
    private queryCache;
    private preAggregations;
    private queryResults;
    private externalDriverFactory;
    private requestId;
    private versionEntries;
    private tables;
    private tableColumnTypes;
    private queryStageState;
    private dataSource;
    private tablePrefixes;
    constructor(redisPrefix: any, clientFactory: DriverFactory, queryCache: any, preAggregations: any, options?: PreAggregationLoadCacheOptions);
    protected tablesFromCache(preAggregation: any, forceRenew?: any): Promise<any>;
    fetchTables(preAggregation: PreAggregationDescription): Promise<any>;
    private fetchTablesNoCache;
    tablesCachePrefixKey(preAggregation: PreAggregationDescription): string;
    protected getTablesQuery(preAggregation: any): Promise<TableCacheEntry[]>;
    getTableColumnTypes(preAggregation: PreAggregationDescription, tableName: string): Promise<TableStructure>;
    private calculateVersionEntries;
    getVersionEntries(preAggregation: any): Promise<VersionEntriesObj>;
    keyQueryResult(sqlQuery: QueryWithParams, waitForRenew: boolean, priority: number): Promise<any>;
    hasKeyQueryResult(keyQuery: any): boolean;
    getQueryStage(stageQueryKey: any): Promise<{
        stage: string;
        timeElapsed: number;
    }>;
    protected fetchQueryStageState(queue?: any): Promise<any>;
    reset(preAggregation: any): Promise<void>;
}
type LoadPreAggregationResult = {
    targetTableName: string;
    refreshKeyValues: any[];
    lastUpdatedAt: number;
    buildRangeEnd: string;
    lambdaTable?: InlineTable;
    queryKey?: any[];
    rollupLambdaId?: string;
    partitionRange?: QueryDateRange;
};
export declare class PreAggregationLoader {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    private readonly loadCache;
    private preAggregations;
    preAggregation: any;
    private preAggregationsTablesToTempTables;
    /**
     * Determines whether current instance instantiated for a jobed build query
     * (initialized by the /cubejs-system/v1/pre-aggregations/jobs endpoint) or
     * not.
     */
    private isJob;
    private waitForRenew;
    private forceBuild;
    private orphanedTimeout;
    private externalDriverFactory;
    private requestId;
    private metadata;
    private structureVersionPersistTime;
    private externalRefresh;
    constructor(redisPrefix: string, driverFactory: DriverFactory, logger: any, queryCache: QueryCache, preAggregations: PreAggregations, preAggregation: any, preAggregationsTablesToTempTables: any, loadCache: PreAggregationLoadCache, options?: any);
    loadPreAggregation(throwOnMissingPartition: boolean): Promise<null | LoadPreAggregationResult>;
    protected loadPreAggregationWithKeys(): Promise<LoadPreAggregationResult>;
    private updateLastTouch;
    protected contentVersion(invalidationKeys: any): string;
    protected priority(defaultValue: number): number;
    protected getInvalidationKeyValues(): Promise<any[]>;
    protected getPartitionInvalidationKeyValues(): Promise<any[]>;
    protected scheduleRefresh(invalidationKeys: any, newVersionEntry: any): void;
    protected executeInQueue(invalidationKeys: any, priority: any, newVersionEntry: any): Promise<any>;
    protected preAggregationQueryKey(invalidationKeys: InvalidationKeys): QueryKey;
    protected targetTableName(versionEntry: VersionEntry): string;
    refresh(newVersionEntry: VersionEntry, invalidationKeys: InvalidationKeys, client: any): any;
    protected logExecutingSql(payload: any): void;
    protected queryOptions(invalidationKeys: InvalidationKeys, query: string, params: unknown[], targetTableName: string, newVersionEntry: VersionEntry): {
        queryKey: QueryKey;
        query: string;
        values: unknown[];
        targetTableName: string;
        requestId: string;
        newVersionEntry: VersionEntry;
        buildRangeEnd: any;
    };
    protected refreshStoreInSourceStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, invalidationKeys: InvalidationKeys): Promise<void>;
    protected refreshWriteStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, invalidationKeys: InvalidationKeys): Promise<void>;
    /**
     * Runs export strategy with write access in data source
     */
    protected runWriteStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, invalidationKeys: InvalidationKeys, withTempTable: boolean, dropSourceTempTable: boolean): Promise<void>;
    /**
     * Cleanup tables after write strategy
     */
    protected cleanupWriteStrategy(client: DriverInterface, targetTableName: string, queryOptions: QueryOptions, saveCancelFn: SaveCancelFn, withTempTable: boolean, dropSourceTempTable: boolean): Promise<void>;
    /**
     * Create table (if required) and prepares query options object
     */
    protected prepareWriteStrategy(client: DriverInterface, targetTableName: string, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, invalidationKeys: InvalidationKeys, withTempTable: boolean): Promise<QueryOptions>;
    /**
     * Strategy to copy pre-aggregation from source db (for read-only permissions) to external data
     */
    protected refreshReadOnlyExternalStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, invalidationKeys: InvalidationKeys): Promise<void>;
    protected getUnloadOptions(): UnloadOptions;
    protected getStreamingOptions(): StreamOptions;
    /**
     * prepares download data for future cube store usage
     */
    protected downloadExternalPreAggregation(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, queryOptions: QueryOptions, withTempTable: boolean): Promise<import("@cubejs-backend/base-driver").StreamTableData | import("@cubejs-backend/base-driver").DownloadTableMemoryData | import("@cubejs-backend/base-driver").DownloadTableCSVData>;
    /**
     * prepares download data when temp table = true
     */
    protected getTableDataWithTempTable(client: DriverInterface, table: string, saveCancelFn: SaveCancelFn, queryOptions: QueryOptions, externalDriverCapabilities: DriverCapabilities): Promise<import("@cubejs-backend/base-driver").StreamTableData | import("@cubejs-backend/base-driver").DownloadTableMemoryData | import("@cubejs-backend/base-driver").DownloadTableCSVData>;
    /**
     * prepares download data when temp table = false
     */
    protected getTableDataWithoutTempTable(client: DriverInterface, table: string, saveCancelFn: SaveCancelFn, queryOptions: QueryOptions, externalDriverCapabilities: DriverCapabilities): Promise<import("@cubejs-backend/base-driver").StreamTableData | import("@cubejs-backend/base-driver").DownloadTableMemoryData | import("@cubejs-backend/base-driver").DownloadTableCSVData>;
    protected uploadExternalPreAggregation(tableData: DownloadTableData, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, queryOptions: QueryOptions): Promise<void>;
    protected createIndexes(driver: any, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, queryOptions: QueryOptions): Promise<void>;
    protected prepareIndexesSql(newVersionEntry: VersionEntry, queryOptions: QueryOptions): any;
    protected prepareCreateTableIndexes(newVersionEntry: VersionEntry): any;
    private withDropLock;
    protected dropOrphanedTables(client: DriverInterface, justCreatedTable: string, saveCancelFn: SaveCancelFn, external: boolean, queryOptions: QueryOptions): Promise<boolean>;
    private dropLockKey;
}
interface PreAggsPartitionRangeLoaderOpts {
    maxPartitions: number;
    maxSourceRowLimit: number;
    waitForRenew?: boolean;
    requestId?: string;
    externalRefresh?: boolean;
    forceBuild?: boolean;
    metadata?: any;
    orphanedTimeout?: number;
    lambdaQuery?: LambdaQuery;
    isJob?: boolean;
    compilerCacheFn?: <T>(subKey: string[], cacheFn: () => T) => T;
}
export declare class PreAggregationPartitionRangeLoader {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    private readonly preAggregations;
    private readonly preAggregation;
    private readonly preAggregationsTablesToTempTables;
    private readonly loadCache;
    private readonly options;
    /**
     * Determines whether current instance instantiated for a jobed build query
     * (initialized by the /cubejs-system/v1/pre-aggregations/jobs endpoint) or
     * not.
     */
    protected isJob: boolean;
    protected waitForRenew: boolean;
    protected requestId: string;
    protected lambdaQuery: LambdaQuery;
    protected dataSource: string;
    protected compilerCacheFn: <T>(subKey: string[], cacheFn: () => T) => T;
    constructor(redisPrefix: string, driverFactory: DriverFactory, logger: any, queryCache: QueryCache, preAggregations: PreAggregations, preAggregation: PreAggregationDescription, preAggregationsTablesToTempTables: [string, LoadPreAggregationResult][], loadCache: PreAggregationLoadCache, options?: PreAggsPartitionRangeLoaderOpts);
    private loadRangeQuery;
    protected getInvalidationKeyValues(range: any): Promise<any[]>;
    protected priority(defaultValue: any): any;
    replaceQueryBuildRangeParams(queryValues: string[]): Promise<string[] | null>;
    private replacePartitionSqlAndParams;
    private partitionPreAggregationDescription;
    loadPreAggregations(): Promise<LoadPreAggregationResult>;
    /**
     * Downloads the lambda table from the source DB.
     */
    private downloadLambdaTable;
    partitionPreAggregations(): Promise<PreAggregationDescription[]>;
    private partitionRanges;
    loadBuildRange(): Promise<QueryDateRange>;
    private now;
    private orNowIfEmpty;
    private static checkDataRangeType;
    static intersectDateRanges(rangeA: QueryDateRange | null, rangeB: QueryDateRange | null): QueryDateRange;
    static timeSeries(granularity: string, dateRange: QueryDateRange): QueryDateRange[];
    static partitionTableName(tableName: string, partitionGranularity: string, dateRange: string[]): string;
    static inDbTimeZone(preAggregationDescription: any, timestamp: string): string;
    static extractDate(data: any): string;
    static FROM_PARTITION_RANGE: string;
    static TO_PARTITION_RANGE: string;
}
type PreAggregationsOptions = {
    maxPartitions: number;
    maxSourceRowLimit: number;
    preAggregationsSchemaCacheExpire?: number;
    loadCacheQueueOptions?: any;
    queueOptions?: (dataSource: string) => Promise<{
        concurrency: number;
        continueWaitTimeout?: number;
        executionTimeout?: number;
        orphanedTimeout?: number;
        heartBeatInterval?: number;
    }>;
    redisPool?: RedisPool;
    cubeStoreDriverFactory?: () => Promise<CubeStoreDriver>;
    continueWaitTimeout?: number;
    cacheAndQueueDriver?: CacheAndQueryDriverType;
    skipExternalCacheAndQueue?: boolean;
};
type PreAggregationQueryBody = QueryBody & {
    preAggregationsLoadCacheByDataSource?: {
        [key: string]: PreAggregationLoadCache;
    };
};
export declare class PreAggregations {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    options: PreAggregationsOptions;
    externalDriverFactory: DriverFactory;
    structureVersionPersistTime: any;
    private readonly touchTablePersistTime;
    readonly dropPreAggregationsWithoutTouch: boolean;
    private readonly usedTablePersistTime;
    private readonly externalRefresh;
    private readonly loadCacheQueue;
    private readonly queue;
    private readonly getQueueEventsBus;
    private readonly touchCache;
    constructor(redisPrefix: string, driverFactory: DriverFactoryByDataSource, logger: any, queryCache: QueryCache, options: any);
    protected tablesUsedRedisKey(tableName: string): string;
    protected tablesTouchRedisKey(tableName: string): string;
    protected refreshEndReachedKey(): string;
    addTableUsed(tableName: string): Promise<void>;
    tablesUsed(): Promise<any[]>;
    updateLastTouch(tableName: string): Promise<void>;
    tablesTouched(): Promise<any[]>;
    updateRefreshEndReached(): Promise<{
        key: string;
        bytes: number;
    }>;
    getRefreshEndReached(): Promise<number>;
    /**
     * Determines whether the partition table is already exists or not.
     */
    isPartitionExist(request: string, external: boolean, dataSource: string, schema: string, table: string, key: any, token: string): Promise<[boolean, string]>;
    loadAllPreAggregationsIfNeeded(queryBody: PreAggregationQueryBody): Promise<{
        preAggregationsTablesToTempTables: PreAggTableToTempTable[];
        values: null | string[];
    }>;
    /**
     * Determines whether range queries for the preAggregations from the
     * queryBody were cached or not.
     */
    checkPartitionsBuildRangeCache(queryBody: any): Promise<any[]>;
    expandPartitionsInPreAggregations(queryBody: Query): Promise<Query>;
    getQueue(dataSource?: string): Promise<QueryQueue>;
    /**
     * Returns registered queries queues hash table.
     */
    getQueues(): {
        [dataSource: string]: QueryQueue;
    };
    getLoadCacheQueue(dataSource?: string): QueryQueue;
    static preAggregationQueryCacheKey(preAggregation: any): any;
    static targetTableName(versionEntry: any): string;
    static noPreAggregationPartitionsBuiltMessage(preAggregations: PreAggregationDescription[]): string;
    static structureVersion(preAggregation: any): string;
    getVersionEntries(preAggregations: PreAggregationDescription[], requestId: any): Promise<VersionEntry[][]>;
    getQueueState(dataSource: string): Promise<any>;
    cancelQueriesFromQueue(queryKeys: string[], dataSource: string): Promise<void[]>;
}
export {};
//# sourceMappingURL=PreAggregations.d.ts.map