"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryCache = void 0;
const crypto_1 = __importDefault(require("crypto"));
const csv_write_stream_1 = __importDefault(require("csv-write-stream"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const stream_1 = require("stream");
const shared_1 = require("@cubejs-backend/shared");
const cubestore_driver_1 = require("@cubejs-backend/cubestore-driver");
const QueryQueue_1 = require("./QueryQueue");
const ContinueWaitError_1 = require("./ContinueWaitError");
const RedisCacheDriver_1 = require("./RedisCacheDriver");
const LocalCacheDriver_1 = require("./LocalCacheDriver");
const utils_1 = require("./utils");
class QueryCache {
    constructor(redisPrefix, driverFactory, logger, options = {}) {
        this.redisPrefix = redisPrefix;
        this.driverFactory = driverFactory;
        this.logger = logger;
        this.options = options;
        this.queue = {};
        this.externalQueue = null;
        this.withLock = (key, ttl, callback) => this.cacheDriver.withLock(`lock:${key}`, callback, ttl, true);
        switch (options.cacheAndQueueDriver || 'memory') {
            case 'redis':
                this.cacheDriver = new RedisCacheDriver_1.RedisCacheDriver({ pool: options.redisPool });
                break;
            case 'memory':
                this.cacheDriver = new LocalCacheDriver_1.LocalCacheDriver();
                break;
            case 'cubestore':
                if (!options.cubeStoreDriverFactory) {
                    throw new Error('cubeStoreDriverFactory is a required option for Cube Store cache driver');
                }
                this.cacheDriver = new cubestore_driver_1.CubeStoreCacheDriver(options.cubeStoreDriverFactory);
                break;
            default:
                throw new Error(`Unknown cache driver: ${options.cacheAndQueueDriver}`);
        }
        this.memoryCache = new lru_cache_1.default({
            max: options.maxInMemoryCacheEntries || 10000
        });
    }
    /**
     * Returns cache driver instance.
     */
    getCacheDriver() {
        return this.cacheDriver;
    }
    getKey(catalog, key) {
        if (this.cacheDriver instanceof cubestore_driver_1.CubeStoreCacheDriver) {
            return `${this.redisPrefix}#${catalog}:${key}`;
        }
        else {
            return `${catalog}_${this.redisPrefix}_${key}`;
        }
    }
    /**
     * Generates from the `queryBody` the final `sql` query and push it to
     * the queue. Returns promise which will be resolved by the different
     * objects, depend from the original `queryBody` object. For the
     * persistent queries returns the `stream.Writable` instance.
     *
     * @throw Error
     */
    async cachedQueryResult(queryBody, preAggregationsTablesToTempTables) {
        const replacePreAggregationTableNames = (queryAndParams) => (QueryCache.replacePreAggregationTableNames(queryAndParams, preAggregationsTablesToTempTables));
        const query = replacePreAggregationTableNames(queryBody.query);
        const inlineTables = preAggregationsTablesToTempTables.flatMap(([_, preAggregation]) => (preAggregation.lambdaTable ? [preAggregation.lambdaTable] : []));
        let queuePriority = 10;
        if (Number.isInteger(queryBody.queuePriority)) {
            queuePriority = queryBody.queuePriority;
        }
        const forceNoCache = queryBody.forceNoCache || false;
        const { values } = queryBody;
        const cacheKeyQueries = this
            .cacheKeyQueriesFrom(queryBody)
            .map(replacePreAggregationTableNames);
        const renewalThreshold = queryBody.cacheKeyQueries &&
            queryBody.cacheKeyQueries.renewalThreshold;
        const expireSecs = this.getExpireSecs(queryBody);
        const cacheKey = QueryCache.queryCacheKey(queryBody);
        if (!cacheKeyQueries ||
            queryBody.external && this.options.skipExternalCacheAndQueue ||
            queryBody.persistent) {
            if (queryBody.persistent) {
                // stream will be returned here
                return this.queryWithRetryAndRelease(query, values, {
                    cacheKey,
                    priority: queuePriority,
                    external: queryBody.external,
                    requestId: queryBody.requestId,
                    persistent: queryBody.persistent,
                    dataSource: queryBody.dataSource,
                    useCsvQuery: queryBody.useCsvQuery,
                    lambdaTypes: queryBody.lambdaTypes,
                    aliasNameToMember: queryBody.aliasNameToMember,
                });
            }
            else {
                return {
                    data: await this.queryWithRetryAndRelease(query, values, {
                        cacheKey: [query, values],
                        external: queryBody.external,
                        requestId: queryBody.requestId,
                        dataSource: queryBody.dataSource,
                        persistent: queryBody.persistent,
                        inlineTables,
                    }),
                };
            }
        }
        if (queryBody.renewQuery) {
            this.logger('Requested renew', { cacheKey, requestId: queryBody.requestId });
            return this.renewQuery(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, {
                external: queryBody.external,
                requestId: queryBody.requestId,
                dataSource: queryBody.dataSource,
                persistent: queryBody.persistent,
            });
        }
        if (!this.options.backgroundRenew) {
            const resultPromise = this.renewQuery(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, {
                external: queryBody.external,
                requestId: queryBody.requestId,
                dataSource: queryBody.dataSource,
                persistent: queryBody.persistent,
                skipRefreshKeyWaitForRenew: true,
            });
            this.startRenewCycle(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, {
                external: queryBody.external,
                requestId: queryBody.requestId,
                dataSource: queryBody.dataSource,
                persistent: queryBody.persistent,
            });
            return resultPromise;
        }
        this.logger('Background fetch', { cacheKey, requestId: queryBody.requestId });
        const mainPromise = this.cacheQueryResult(query, values, cacheKey, expireSecs, {
            priority: queuePriority,
            forceNoCache,
            external: queryBody.external,
            requestId: queryBody.requestId,
            dataSource: queryBody.dataSource,
            persistent: queryBody.persistent,
        });
        if (!forceNoCache) {
            this.startRenewCycle(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, {
                external: queryBody.external,
                requestId: queryBody.requestId,
                dataSource: queryBody.dataSource,
                persistent: queryBody.persistent,
            });
        }
        return {
            data: await mainPromise,
            lastRefreshTime: await this.lastRefreshTime(cacheKey)
        };
    }
    getExpireSecs(queryBody) {
        return queryBody.expireSecs || 24 * 3600;
    }
    cacheKeyQueriesFrom(queryBody) {
        return queryBody.cacheKeyQueries && queryBody.cacheKeyQueries.queries ||
            queryBody.cacheKeyQueries ||
            [];
    }
    static queryCacheKey(queryBody) {
        const key = [
            queryBody.query,
            queryBody.values,
            (queryBody.preAggregations || []).map(p => p.loadSql)
        ];
        if (queryBody.invalidate) {
            key.push(queryBody.invalidate);
        }
        // @ts-ignore
        key.persistent = queryBody.persistent;
        return key;
    }
    static replaceAll(replaceThis, withThis, inThis) {
        withThis = withThis.replace(/\$/g, '$$$$');
        return inThis.replace(new RegExp(replaceThis.replace(/([/,!\\^${}[\]().*+?|<>\-&])/g, '\\$&'), 'g'), withThis);
    }
    static replacePreAggregationTableNames(queryAndParams, preAggregationsTablesToTempTables) {
        const [keyQuery, params, queryOptions] = Array.isArray(queryAndParams)
            ? queryAndParams
            : [queryAndParams, []];
        const replacedKeyQuery = preAggregationsTablesToTempTables.reduce((query, [tableName, { targetTableName }]) => (QueryCache.replaceAll(tableName, targetTableName, query)), keyQuery);
        return Array.isArray(queryAndParams)
            ? [replacedKeyQuery, params, queryOptions]
            : replacedKeyQuery;
    }
    /**
     * Determines queue type, resolves `QueryQueue` instance and runs the
     * `executeInQueue` method passing incoming `query` into it. Resolves
     * promise with the `executeInQueue` method result for the not persistent
     * queries and with the `stream.Writable` instance for the persistent.
     */
    async queryWithRetryAndRelease(query, values, { cacheKey, dataSource, external, priority, requestId, spanId, inlineTables, useCsvQuery, lambdaTypes, persistent, aliasNameToMember, }) {
        const queue = external
            ? this.getExternalQueue()
            : await this.getQueue(dataSource);
        const _query = {
            queryKey: cacheKey,
            query,
            values,
            requestId,
            inlineTables,
            useCsvQuery,
            lambdaTypes,
        };
        const opt = {
            stageQueryKey: cacheKey,
            requestId,
            spanId,
        };
        if (!persistent) {
            return queue.executeInQueue('query', cacheKey, _query, priority, opt);
        }
        else {
            return queue.executeInQueue('stream', cacheKey, {
                ..._query,
                aliasNameToMember,
            }, priority, opt);
        }
    }
    async getQueue(dataSource = 'default') {
        if (!this.queue[dataSource]) {
            const queueOptions = await this.options.queueOptions(dataSource);
            if (!this.queue[dataSource]) {
                this.queue[dataSource] = QueryCache.createQueue(`SQL_QUERY_${this.redisPrefix}_${dataSource}`, () => this.driverFactory(dataSource), (client, req) => {
                    this.logger('Executing SQL', { ...req });
                    if (req.useCsvQuery) {
                        return this.csvQuery(client, req);
                    }
                    else {
                        return client.query(req.query, req.values, req);
                    }
                }, {
                    logger: this.logger,
                    cacheAndQueueDriver: this.options.cacheAndQueueDriver,
                    redisPool: this.options.redisPool,
                    cubeStoreDriverFactory: this.options.cubeStoreDriverFactory,
                    // Centralized continueWaitTimeout that can be overridden in queueOptions
                    continueWaitTimeout: this.options.continueWaitTimeout,
                    ...queueOptions,
                });
            }
        }
        return this.queue[dataSource];
    }
    async csvQuery(client, q) {
        const headers = q.lambdaTypes.map(c => c.name);
        const writer = (0, csv_write_stream_1.default)({
            headers,
            sendHeaders: false,
        });
        let tableData;
        try {
            if (client.stream) {
                tableData = await client.stream(q.query, q.values, q);
                const errors = [];
                await (0, stream_1.pipeline)(tableData.rowStream, writer, (err) => {
                    if (err) {
                        errors.push(err);
                    }
                });
                if (errors.length > 0) {
                    throw new Error(`Lambda query errors ${errors.join(', ')}`);
                }
            }
            else {
                tableData = await client.downloadQueryResults(q.query, q.values, q);
                tableData.rows.forEach(row => writer.write(row));
                writer.end();
            }
        }
        finally {
            if (tableData?.release) {
                await tableData.release();
            }
        }
        const lines = await (0, shared_1.streamToArray)(writer);
        const rowCount = lines.length;
        const csvRows = lines.join('');
        return {
            types: q.lambdaTypes,
            csvRows,
            rowCount,
        };
    }
    getExternalQueue() {
        if (!this.externalQueue) {
            this.externalQueue = QueryCache.createQueue(`SQL_QUERY_EXT_${this.redisPrefix}`, this.options.externalDriverFactory, (client, q) => {
                this.logger('Executing SQL', {
                    ...q
                });
                return client.query(q.query, q.values, q);
            }, {
                logger: this.logger,
                cacheAndQueueDriver: this.options.cacheAndQueueDriver,
                redisPool: this.options.redisPool,
                cubeStoreDriverFactory: this.options.cubeStoreDriverFactory,
                // Centralized continueWaitTimeout that can be overridden in queueOptions
                continueWaitTimeout: this.options.continueWaitTimeout,
                skipQueue: this.options.skipExternalCacheAndQueue,
                ...this.options.externalQueueOptions
            });
        }
        return this.externalQueue;
    }
    static createQueue(redisPrefix, clientFactory, executeFn, options = {}) {
        const queue = new QueryQueue_1.QueryQueue(redisPrefix, {
            getQueueEventsBus: options.getQueueEventsBus,
            queryHandlers: {
                query: async (req, setCancelHandle) => {
                    const client = await clientFactory();
                    const resultPromise = executeFn(client, req);
                    let handle;
                    if (resultPromise.cancel) {
                        queue.cancelHandlerCounter += 1;
                        handle = queue.cancelHandlerCounter;
                        queue.handles[handle] = resultPromise;
                        await setCancelHandle(handle);
                    }
                    const result = await resultPromise;
                    if (handle) {
                        delete queue.handles[handle];
                    }
                    return result;
                },
                stream: async (req, target) => {
                    queue.logger('Streaming SQL', { ...req });
                    await (new Promise((resolve, reject) => {
                        let logged = false;
                        Promise
                            .all([clientFactory()])
                            .then(([client]) => client.stream(req.query, req.values, { highWaterMark: (0, shared_1.getEnv)('dbQueryStreamHighWaterMark') }))
                            .then((source) => {
                            const cleanup = async (error) => {
                                if (source.release) {
                                    const toRelease = source.release;
                                    delete source.release;
                                    await toRelease();
                                }
                                if (error && !target.destroyed) {
                                    target.destroy(error);
                                }
                                if (!logged && target.destroyed) {
                                    logged = true;
                                    if (error) {
                                        queue.logger('Streaming done with error', {
                                            query: req.query,
                                            query_values: req.values,
                                            error,
                                        });
                                        reject(error);
                                    }
                                    else {
                                        queue.logger('Streaming successfully completed', {
                                            requestId: req.requestId,
                                        });
                                        resolve(req.requestId);
                                    }
                                }
                            };
                            source.rowStream.once('end', () => cleanup(undefined));
                            source.rowStream.once('error', cleanup);
                            source.rowStream.once('close', () => cleanup(undefined));
                            target.once('end', () => cleanup(undefined));
                            target.once('error', cleanup);
                            target.once('close', () => cleanup(undefined));
                            source.rowStream.pipe(target);
                        })
                            .catch((reason) => {
                            target.emit('error', reason);
                            resolve(reason);
                        });
                    }));
                },
            },
            cancelHandlers: {
                query: async (req) => {
                    if (req.cancelHandler && queue.handles[req.cancelHandler]) {
                        await queue.handles[req.cancelHandler].cancel();
                        delete queue.handles[req.cancelHandler];
                    }
                },
                stream: async (req) => {
                    req.queryKey.persistent = true;
                    const queryKeyHash = queue.redisHash(req.queryKey);
                    if (queue.streams.has(queryKeyHash)) {
                        queue.streams.get(queryKeyHash).destroy();
                    }
                },
            },
            logger: (msg, params) => options.logger(msg, params),
            ...options
        });
        queue.cancelHandlerCounter = 0;
        queue.handles = {};
        return queue;
    }
    /**
     * Returns registered queries queues hash table.
     */
    getQueues() {
        return this.queue;
    }
    startRenewCycle(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, options) {
        this.renewQuery(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, {
            ...options,
            renewCycle: true
        }).catch(e => {
            if (!(e instanceof ContinueWaitError_1.ContinueWaitError)) {
                this.logger('Error while renew cycle', {
                    query, query_values: values, error: e.stack || e, requestId: options.requestId
                });
            }
        });
    }
    renewQuery(query, values, cacheKeyQueries, expireSecs, cacheKey, renewalThreshold, options) {
        options = options || { dataSource: 'default' };
        return Promise.all(this.loadRefreshKeys(cacheKeyQueries, expireSecs, options))
            .catch(e => {
            if (e instanceof ContinueWaitError_1.ContinueWaitError) {
                throw e;
            }
            this.logger('Error fetching cache key queries', { error: e.stack || e, requestId: options.requestId });
            return [];
        })
            .then(async (cacheKeyQueryResults) => ({
            data: await this.cacheQueryResult(query, values, cacheKey, expireSecs, {
                renewalThreshold: renewalThreshold || 6 * 60 * 60,
                renewalKey: cacheKeyQueryResults && [
                    cacheKeyQueries,
                    cacheKeyQueryResults,
                    this.queryRedisKey([query, values]),
                ],
                waitForRenew: true,
                external: options.external,
                requestId: options.requestId,
                dataSource: options.dataSource,
                useCsvQuery: options.useCsvQuery,
                lambdaTypes: options.lambdaTypes,
                persistent: options.persistent,
                primaryQuery: true,
                renewCycle: options.renewCycle,
            }),
            refreshKeyValues: cacheKeyQueryResults,
            lastRefreshTime: await this.lastRefreshTime(cacheKey)
        }));
    }
    async loadRefreshKeysFromQuery(query) {
        return Promise.all(this.loadRefreshKeys(this.cacheKeyQueriesFrom(query), this.getExpireSecs(query), {
            requestId: query.requestId,
            dataSource: query.dataSource,
        }));
    }
    loadRefreshKeys(cacheKeyQueries, expireSecs, options) {
        return cacheKeyQueries.map((q) => {
            const [query, values, queryOptions] = Array.isArray(q) ? q : [q, [], {}];
            return this.cacheQueryResult(query, values, [query, values], expireSecs, {
                renewalThreshold: this.options.refreshKeyRenewalThreshold || queryOptions?.renewalThreshold || 2 * 60,
                renewalKey: q,
                waitForRenew: !options.skipRefreshKeyWaitForRenew,
                requestId: options.requestId,
                dataSource: options.dataSource,
                useInMemory: true,
                external: queryOptions?.external,
            });
        });
    }
    async cacheQueryResult(query, values, cacheKey, expiration, options) {
        const spanId = crypto_1.default.randomBytes(16).toString('hex');
        options = options || { dataSource: 'default' };
        const { renewalThreshold, primaryQuery, renewCycle } = options;
        const renewalKey = options.renewalKey && this.queryRedisKey(options.renewalKey);
        const redisKey = this.queryRedisKey(cacheKey);
        const fetchNew = () => (this.queryWithRetryAndRelease(query, values, {
            cacheKey,
            priority: options.priority,
            external: options.external,
            requestId: options.requestId,
            spanId,
            persistent: options.persistent,
            dataSource: options.dataSource,
            useCsvQuery: options.useCsvQuery,
            lambdaTypes: options.lambdaTypes,
        }).then(res => {
            const result = {
                time: (new Date()).getTime(),
                result: res,
                renewalKey
            };
            return this
                .cacheDriver
                .set(redisKey, result, expiration)
                .then(({ bytes }) => {
                this.logger('Renewed', { cacheKey, requestId: options.requestId, spanId, primaryQuery, renewCycle });
                this.logger('Outgoing network usage', {
                    service: 'cache',
                    requestId: options.requestId,
                    spanId,
                    bytes,
                    cacheKey,
                });
                return res;
            });
        }).catch(e => {
            if (!(e instanceof ContinueWaitError_1.ContinueWaitError)) {
                this.logger('Dropping Cache', { cacheKey, error: e.stack || e, requestId: options.requestId, spanId, primaryQuery, renewCycle });
                this.cacheDriver.remove(redisKey)
                    .catch(err => this.logger('Error removing key', {
                    cacheKey,
                    spanId,
                    error: err.stack || err,
                    requestId: options.requestId
                }));
            }
            throw e;
        }));
        if (options.forceNoCache) {
            this.logger('Force no cache for', { cacheKey, requestId: options.requestId, spanId, primaryQuery, renewCycle });
            return fetchNew();
        }
        let res;
        const inMemoryCacheDisablePeriod = 5 * 60 * 1000;
        if (options.useInMemory) {
            const inMemoryValue = this.memoryCache.get(redisKey);
            if (inMemoryValue) {
                const renewedAgo = (new Date()).getTime() - inMemoryValue.time;
                if (renewalKey && (!renewalThreshold ||
                    !inMemoryValue.time ||
                    // Do not cache in memory in last 5 minutes of expiry.
                    // Most likely it'll cause race condition of refreshing data with different refreshKey values.
                    renewedAgo + inMemoryCacheDisablePeriod > renewalThreshold * 1000 ||
                    inMemoryValue.renewalKey !== renewalKey) || renewedAgo > expiration * 1000 || renewedAgo > inMemoryCacheDisablePeriod) {
                    this.memoryCache.del(redisKey);
                }
                else {
                    this.logger('Found in memory cache entry', {
                        cacheKey,
                        time: inMemoryValue.time,
                        renewedAgo,
                        renewalKey: inMemoryValue.renewalKey,
                        newRenewalKey: renewalKey,
                        renewalThreshold,
                        requestId: options.requestId,
                        spanId,
                        primaryQuery,
                        renewCycle
                    });
                    res = inMemoryValue;
                }
            }
        }
        if (!res) {
            res = await this.cacheDriver.get(redisKey);
        }
        if (res) {
            const parsedResult = res;
            const renewedAgo = (new Date()).getTime() - parsedResult.time;
            this.logger('Found cache entry', {
                cacheKey,
                time: parsedResult.time,
                renewedAgo,
                renewalKey: parsedResult.renewalKey,
                newRenewalKey: renewalKey,
                renewalThreshold,
                requestId: options.requestId,
                spanId,
                primaryQuery,
                renewCycle
            });
            if (renewalKey && (!renewalThreshold ||
                !parsedResult.time ||
                renewedAgo > renewalThreshold * 1000 ||
                parsedResult.renewalKey !== renewalKey)) {
                if (options.waitForRenew) {
                    this.logger('Waiting for renew', { cacheKey, renewalThreshold, requestId: options.requestId, spanId, primaryQuery, renewCycle });
                    return fetchNew();
                }
                else {
                    this.logger('Renewing existing key', { cacheKey, renewalThreshold, requestId: options.requestId, spanId, primaryQuery, renewCycle });
                    fetchNew().catch(e => {
                        if (!(e instanceof ContinueWaitError_1.ContinueWaitError)) {
                            this.logger('Error renewing', { cacheKey, error: e.stack || e, requestId: options.requestId, spanId, primaryQuery, renewCycle });
                        }
                    });
                }
            }
            this.logger('Using cache for', { cacheKey, requestId: options.requestId, spanId, primaryQuery, renewCycle });
            if (options.useInMemory && renewedAgo + inMemoryCacheDisablePeriod <= renewalThreshold * 1000) {
                this.memoryCache.set(redisKey, parsedResult);
            }
            return parsedResult.result;
        }
        else {
            this.logger('Missing cache for', { cacheKey, requestId: options.requestId, spanId, primaryQuery, renewCycle });
            return fetchNew();
        }
    }
    async lastRefreshTime(cacheKey) {
        const cachedValue = await this.cacheDriver.get(this.queryRedisKey(cacheKey));
        return cachedValue && new Date(cachedValue.time);
    }
    async resultFromCacheIfExists(queryBody) {
        const cacheKey = QueryCache.queryCacheKey(queryBody);
        const cachedValue = await this.cacheDriver.get(this.queryRedisKey(cacheKey));
        if (cachedValue) {
            return {
                data: cachedValue.result,
                lastRefreshTime: new Date(cachedValue.time)
            };
        }
        return null;
    }
    queryRedisKey(cacheKey) {
        return this.getKey('SQL_QUERY_RESULT', (0, utils_1.getCacheHash)(cacheKey));
    }
    async cleanup() {
        return this.cacheDriver.cleanup();
    }
    async testConnection() {
        return this.cacheDriver.testConnection();
    }
}
exports.QueryCache = QueryCache;
//# sourceMappingURL=QueryCache.js.map