import { QueueDriverInterface, QueueDriverConnectionInterface, QueueDriverOptions, GetActiveAndToProcessResponse, QueryDef, QueryKeyHash, QueryStageStateResponse, QueryKey, AddToQueueQuery, AddToQueueOptions, AddToQueueResponse, ProcessingId, RetrieveForProcessingResponse, QueryKeysTuple } from '@cubejs-backend/base-driver';
import { BaseQueueDriver } from './BaseQueueDriver';
import { RedisPool } from './RedisPool';
type AsyncRedisClient = any;
interface RedisQueueDriverConnectionOptions extends QueueDriverOptions {
    redisClient: AsyncRedisClient;
}
export declare class RedisQueueDriverConnection implements QueueDriverConnectionInterface {
    protected readonly redisClient: AsyncRedisClient;
    protected readonly driver: RedisQueueDriver;
    protected readonly redisQueuePrefix: string;
    protected readonly heartBeatTimeout: number;
    protected readonly concurrency: number;
    protected readonly getQueueEventsBus: any;
    protected readonly continueWaitTimeout: number;
    constructor(driver: RedisQueueDriver, options: RedisQueueDriverConnectionOptions);
    getRedisClient(): any;
    getResultBlocking(queryKeyHash: any): Promise<any>;
    getResult(queryKey: any): Promise<any>;
    getQueriesToCancel(): Promise<QueryKeysTuple[]>;
    getActiveAndToProcess(): Promise<GetActiveAndToProcessResponse>;
    addToQueue(keyScore: number, queryKey: QueryKey, orphanedTime: number, queryHandler: string, query: AddToQueueQuery, priority: number, options: AddToQueueOptions): Promise<AddToQueueResponse>;
    getToProcessQueries(): Promise<QueryKeysTuple[]>;
    getActiveQueries(): Promise<QueryKeysTuple[]>;
    getQueryAndRemove(queryKey: QueryKeyHash): Promise<[QueryDef]>;
    cancelQuery(queryKey: any): Promise<unknown>;
    setResultAndRemoveQuery(queryKey: any, executionResult: any, processingId: any): Promise<any>;
    getOrphanedQueries(): Promise<QueryKeysTuple[]>;
    getStalledQueries(): Promise<QueryKeysTuple[]>;
    getQueryStageState(onlyKeys: boolean): Promise<QueryStageStateResponse>;
    getQueryDef(queryKey: any): Promise<any>;
    /**
     * Updates heart beat for the processing query by its `queryKey`.
     */
    updateHeartBeat(queryKey: any): Promise<any>;
    getNextProcessingId(): Promise<any>;
    retrieveForProcessing(queryKey: QueryKeyHash, processingId: ProcessingId): Promise<RetrieveForProcessingResponse>;
    freeProcessingLock(queryKey: any, processingId: any, activated: any): Promise<any>;
    optimisticQueryUpdate(queryKey: any, toUpdate: any, processingId: any): Promise<boolean>;
    release(): any;
    protected toProcessRedisKey(): string;
    protected recentRedisKey(): string;
    protected activeRedisKey(): string;
    protected heartBeatRedisKey(): string;
    protected queryRedisKey(queryKey: any, suffix: any): string;
    protected queueRedisKey(suffix: any): string;
    protected queriesDefKey(): string;
    protected processingIdKey(): string;
    protected resultListKey(queryKey: any): string;
    protected queryProcessingLockKey(queryKey: any): string;
    redisHash(queryKey: any): QueryKeyHash;
}
interface RedisQueueDriverOptions extends QueueDriverOptions {
    redisPool: RedisPool;
}
export declare class RedisQueueDriver extends BaseQueueDriver implements QueueDriverInterface {
    protected readonly redisPool: RedisPool;
    protected readonly options: RedisQueueDriverOptions;
    constructor(options: RedisQueueDriverOptions);
    createConnection(): Promise<RedisQueueDriverConnection>;
    release(connection: RedisQueueDriverConnection): void;
}
export {};
//# sourceMappingURL=RedisQueueDriver.d.ts.map