/// <reference types="node" />
import * as stream from 'stream';
import { QueryCache, QueryBody } from './QueryCache';
import { PreAggregations, PreAggregationDescription } from './PreAggregations';
import { RedisPool, RedisPoolOptions } from './RedisPool';
import { DriverFactory, DriverFactoryByDataSource } from './DriverFactory';
export type CacheAndQueryDriverType = 'redis' | 'memory' | 'cubestore';
export declare enum DriverType {
    External = "external",
    Internal = "internal",
    Cache = "cache"
}
export interface QueryOrchestratorOptions {
    externalDriverFactory?: DriverFactory;
    cacheAndQueueDriver?: CacheAndQueryDriverType;
    redisPoolOptions?: RedisPoolOptions;
    queryCacheOptions?: any;
    preAggregationsOptions?: any;
    rollupOnlyMode?: boolean;
    continueWaitTimeout?: number;
    skipExternalCacheAndQueue?: boolean;
}
export declare class QueryOrchestrator {
    protected readonly redisPrefix: string;
    protected readonly driverFactory: DriverFactoryByDataSource;
    protected readonly logger: any;
    protected queryCache: QueryCache;
    protected readonly preAggregations: PreAggregations;
    protected readonly redisPool: RedisPool | undefined;
    protected readonly rollupOnlyMode: boolean;
    private queueEventsBus;
    protected readonly cacheAndQueueDriver: string;
    constructor(redisPrefix: string, driverFactory: DriverFactoryByDataSource, logger: any, options?: QueryOrchestratorOptions);
    private getQueueEventsBus;
    /**
     * Returns QueryCache instance.
     */
    getQueryCache(): QueryCache;
    /**
     * Returns PreAggregations instance.
     */
    getPreAggregations(): PreAggregations;
    /**
     * Force reconcile queue logic to be executed.
     */
    forceReconcile(datasource?: string): Promise<void>;
    /**
     * Determines whether the partition table is already exists or not.
     */
    isPartitionExist(request: string, external: boolean, dataSource: string, schema: string, table: string, key: any, token: string): Promise<[boolean, string]>;
    /**
     * Returns stream object which will be used to stream results from
     * the data source if applicable. Throw otherwise.
     *
     * @throw Error
     */
    streamQuery(query: QueryBody): Promise<stream.Transform>;
    /**
     * Push query to the queue, fetch and return result if query takes
     * less than `continueWaitTimeout` seconds, throw `ContinueWaitError`
     * error otherwise.
     *
     * @throw ContinueWaitError
     */
    fetchQuery(queryBody: QueryBody): Promise<any>;
    loadRefreshKeys(query: any): Promise<any[]>;
    queryStage(queryBody: any): Promise<{
        stage: string;
        timeElapsed: number;
    }>;
    resultFromCacheIfExists(queryBody: any): Promise<{
        data: any;
        lastRefreshTime: Date;
    }>;
    testConnections(): Promise<void>;
    cleanup(): Promise<void>;
    getPreAggregationVersionEntries(preAggregations: {
        preAggregation: any;
        partitions: any[];
    }[], preAggregationsSchema: string, requestId: string): Promise<{
        structureVersionsByTableName: any;
        versionEntriesByTableName: any;
    }>;
    getPreAggregationPreview(requestId: string, preAggregation: PreAggregationDescription): Promise<any>;
    expandPartitionsInPreAggregations(queryBody: any): Promise<import("./QueryCache").Query>;
    checkPartitionsBuildRangeCache(queryBody: any): Promise<any[]>;
    getPreAggregationQueueStates(dataSource?: string): Promise<any>;
    cancelPreAggregationQueriesFromQueue(queryKeys: string[], dataSource?: string): Promise<void[]>;
    subscribeQueueEvents(id: any, callback: any): Promise<void>;
    unSubscribeQueueEvents(id: any): Promise<void>;
    updateRefreshEndReached(): Promise<{
        key: string;
        bytes: number;
    }>;
}
//# sourceMappingURL=QueryOrchestrator.d.ts.map