import LRUCache from 'lru-cache';
import { MaybeCancelablePromise } from '@cubejs-backend/shared';
import { CubeStoreDriver } from '@cubejs-backend/cubestore-driver';
import { BaseDriver, InlineTables, CacheDriverInterface, TableStructure } from '@cubejs-backend/base-driver';
import { QueryQueue } from './QueryQueue';
import { DriverFactory, DriverFactoryByDataSource } from './DriverFactory';
import { PreAggregationDescription } from './PreAggregations';
import { CacheAndQueryDriverType } from './QueryOrchestrator';
type QueryOptions = {
    external?: boolean;
    renewalThreshold?: number;
    updateWindowSeconds?: number;
    renewalThresholdOutsideUpdateWindow?: number;
    incremental?: boolean;
};
export type QueryTuple = [
    sql: string,
    params: unknown[],
    options?: QueryOptions
];
export type QueryWithParams = QueryTuple;
export type Query = {
    requestId?: string;
    dataSource: string;
    preAggregations?: PreAggregationDescription[];
    groupedPartitionPreAggregations?: PreAggregationDescription[][];
    preAggregationsLoadCacheByDataSource?: any;
    renewQuery?: boolean;
    compilerCacheFn?: <T>(subKey: string[], cacheFn: () => T) => T;
};
export type QueryBody = {
    dataSource?: string;
    persistent?: boolean;
    query?: string;
    values?: string[];
    continueWait?: boolean;
    renewQuery?: boolean;
    requestId?: string;
    external?: boolean;
    isJob?: boolean;
    forceNoCache?: boolean;
    preAggregations?: PreAggregationDescription[];
    groupedPartitionPreAggregations?: PreAggregationDescription[][];
    aliasNameToMember?: {
        [alias: string]: string;
    };
    preAggregationsLoadCacheByDataSource?: {
        [key: string]: any;
    };
    [key: string]: any;
};
/**
 * Temp (partition/lambda) table definition.
 */
export type TempTable = {
    type: string;
    buildRangeEnd: string;
    lastUpdatedAt: number;
    queryKey: unknown;
    refreshKeyValues: [
        {
            'refresh_key': string;
        }
    ][];
    targetTableName: string;
    lambdaTable?: {
        name: string;
        columns: {
            name: string;
            type: string;
            attributes?: string[];
        }[];
        csvRows: string;
    };
};
/**
 * Pre-aggregation table (stored in the first element) to temp table
 * definition (stored in the second element) link.
 */
export type PreAggTableToTempTable = [
    string,
    TempTable
];
export type CacheKey = string | [
    query: string | QueryTuple,
    options?: string[]
];
type CacheEntry = {
    time: number;
    result: any;
    renewalKey: string;
};
export interface QueryCacheOptions {
    refreshKeyRenewalThreshold?: number;
    externalQueueOptions?: any;
    externalDriverFactory?: DriverFactory;
    backgroundRenew?: Boolean;
    queueOptions?: (dataSource: string) => Promise<{
        concurrency: number;
        continueWaitTimeout?: number;
        executionTimeout?: number;
        orphanedTimeout?: number;
        heartBeatInterval?: number;
    }>;
    redisPool?: any;
    cubeStoreDriverFactory?: () => Promise<CubeStoreDriver>;
    continueWaitTimeout?: number;
    cacheAndQueueDriver?: CacheAndQueryDriverType;
    maxInMemoryCacheEntries?: number;
    skipExternalCacheAndQueue?: boolean;
}
export declare class QueryCache {
    protected readonly redisPrefix: string;
    protected readonly driverFactory: DriverFactoryByDataSource;
    protected readonly logger: any;
    readonly options: QueryCacheOptions;
    protected readonly cacheDriver: CacheDriverInterface;
    protected queue: {
        [dataSource: string]: QueryQueue;
    };
    protected externalQueue: QueryQueue | null;
    protected memoryCache: LRUCache<string, CacheEntry>;
    constructor(redisPrefix: string, driverFactory: DriverFactoryByDataSource, logger: any, options?: QueryCacheOptions);
    /**
     * Returns cache driver instance.
     */
    getCacheDriver(): CacheDriverInterface;
    getKey(catalog: string, key: string): string;
    /**
     * Generates from the `queryBody` the final `sql` query and push it to
     * the queue. Returns promise which will be resolved by the different
     * objects, depend from the original `queryBody` object. For the
     * persistent queries returns the `stream.Writable` instance.
     *
     * @throw Error
     */
    cachedQueryResult(queryBody: QueryBody, preAggregationsTablesToTempTables: PreAggTableToTempTable[]): Promise<any>;
    private getExpireSecs;
    private cacheKeyQueriesFrom;
    static queryCacheKey(queryBody: QueryBody): CacheKey;
    protected static replaceAll(replaceThis: any, withThis: any, inThis: any): any;
    static replacePreAggregationTableNames(queryAndParams: string | QueryWithParams, preAggregationsTablesToTempTables: PreAggTableToTempTable[]): string | QueryTuple;
    /**
     * Determines queue type, resolves `QueryQueue` instance and runs the
     * `executeInQueue` method passing incoming `query` into it. Resolves
     * promise with the `executeInQueue` method result for the not persistent
     * queries and with the `stream.Writable` instance for the persistent.
     */
    queryWithRetryAndRelease(query: string | QueryTuple, values: string[], { cacheKey, dataSource, external, priority, requestId, spanId, inlineTables, useCsvQuery, lambdaTypes, persistent, aliasNameToMember, }: {
        cacheKey: CacheKey;
        dataSource: string;
        external: boolean;
        priority?: number;
        requestId?: string;
        spanId?: string;
        inlineTables?: InlineTables;
        useCsvQuery?: boolean;
        lambdaTypes?: TableStructure;
        persistent?: boolean;
        aliasNameToMember?: {
            [alias: string]: string;
        };
    }): Promise<any>;
    getQueue(dataSource?: string): Promise<QueryQueue>;
    protected csvQuery(client: any, q: any): Promise<{
        types: any;
        csvRows: string;
        rowCount: number;
    }>;
    getExternalQueue(): QueryQueue;
    static createQueue(redisPrefix: string, clientFactory: DriverFactory, executeFn: (client: BaseDriver, req: any) => any, options?: Record<string, any>): QueryQueue;
    /**
     * Returns registered queries queues hash table.
     */
    getQueues(): {
        [dataSource: string]: QueryQueue;
    };
    startRenewCycle(query: string | QueryTuple, values: string[], cacheKeyQueries: (string | QueryTuple)[], expireSecs: number, cacheKey: CacheKey, renewalThreshold: any, options: {
        requestId?: string;
        skipRefreshKeyWaitForRenew?: boolean;
        external?: boolean;
        dataSource: string;
        persistent?: boolean;
    }): void;
    renewQuery(query: string | QueryTuple, values: string[], cacheKeyQueries: (string | QueryTuple)[], expireSecs: number, cacheKey: CacheKey, renewalThreshold: any, options: {
        requestId?: string;
        skipRefreshKeyWaitForRenew?: boolean;
        external?: boolean;
        dataSource: string;
        useCsvQuery?: boolean;
        lambdaTypes?: TableStructure;
        persistent?: boolean;
        renewCycle?: boolean;
    }): Promise<{
        data: any;
        refreshKeyValues: any[];
        lastRefreshTime: Date;
    }>;
    loadRefreshKeysFromQuery(query: Query): Promise<any[]>;
    loadRefreshKeys(cacheKeyQueries: QueryWithParams[], expireSecs: number, options: {
        requestId?: string;
        skipRefreshKeyWaitForRenew?: boolean;
        dataSource: string;
    }): Promise<any>[];
    withLock: <T = any>(key: string, ttl: number, callback: () => MaybeCancelablePromise<T>) => import("@cubejs-backend/shared").CancelablePromise<boolean>;
    cacheQueryResult(query: string | QueryTuple, values: string[], cacheKey: CacheKey, expiration: number, options: {
        renewalThreshold?: number;
        renewalKey?: any;
        priority?: number;
        external?: boolean;
        requestId?: string;
        dataSource: string;
        waitForRenew?: boolean;
        forceNoCache?: boolean;
        useInMemory?: boolean;
        useCsvQuery?: boolean;
        lambdaTypes?: TableStructure;
        persistent?: boolean;
        primaryQuery?: boolean;
        renewCycle?: boolean;
    }): Promise<any>;
    protected lastRefreshTime(cacheKey: any): Promise<Date>;
    resultFromCacheIfExists(queryBody: any): Promise<{
        data: any;
        lastRefreshTime: Date;
    }>;
    queryRedisKey(cacheKey: any): string;
    cleanup(): Promise<void>;
    testConnection(): Promise<void>;
}
export {};
//# sourceMappingURL=QueryCache.d.ts.map